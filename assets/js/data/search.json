[ { "title": "NixImports a .NET loader using HInvoke", "url": "/posts/NixImports-a-NET-loader-using-HInvoke/", "categories": "dotnet, malware, redteam", "tags": "", "date": "2023-05-22 13:27:24 +0000", "snippet": "A while ago, I released HInvoke, a project showcasing API hashing for managed functions. The initial release was rather basic and lacked desirable features like support for non-static methods. NixImports is an example showing the use of the new HInvoke. The update includes support for non-static methods as well as support for nonunique method names. In this blog post, I will describe the improvements and showcase the use of HInvoke in a simple .NET loader.The ConceptNixImports aims to build a loader with little to no direct function calls and reduce referenced methods to a minimum. Importing a function in .NET adds some metadata, for example, the namespace and name of the referenced method. This metadata gives away potential capabilities of our binary and can be used for detection, see for example, GDATA’s TypeRefHash. To avoid this kind of metadata as much as possible, NixImports uses my managed API hashing implementation HInvoke. HInvoke does not require the method we want to invoke to be referenced in the assembly; instead, it will dynamically resolve the method or property on runtime, using only two hash values to identify the target method.HInvokeAs mentioned above HInvoke requires two hash values. The first hash identifies the FullName of the type containing our targetted member. The second hash identifies the method or property we want to access. To resolve the desired type and member, HInvoke iterates through all types of mscorlib and generates a hash for each type name; once a matching hash is found, it will iterate through all methods or properties of that type and hash their name or in case of methods ToString value. If the hash matches the supplied second hash, we return the property value or invoke the method and return its result. HInvoke also accepts arguments for the to-be-called method and an instance object for methods and properties. Using the instance object, HInvoke can invoke non-static methods or get properties of instantiated types. To minimize overhead, I added a cache that holds previously resolved member info to avoid expensive re-parsing of mscorlib.Storing Payload DataBesides hiding imports, I wanted to have fun hiding the payload data. We take the payload data and split it into smaller chunks. Next, we Base64 encode the chunks as strings. The encoded strings are then encrypted with a simple ROT cipher and used as names for newly injected methods. The injected methods contain some placeholder code but serve no purpose except storing payload data in their name. During runtime, we ensure the correct order of methods and decrypt the names before converting them back to bytes through Base64 decoding. To make sure we parse the methods in the correct order, I use AsmResolvers TokenAllocator, which allows us to pre-assign tokens to injected methods. After adding the payload data, I patch the loader stub replacing placeholder values with the pre-assigned tokens.The RuntimeNow let us look at the most exciting part of NixImports, the actual loader code. The loader utilizes HInvoke to conceal its function calls and deliberately avoids using traditional functions that analysis tools and EDR software may detect. Wherever possible, NixImports uses the underlying internal functions instead of the public functions. For example, it uses RuntimeAssembly.nLoadImage instead of Assembly.Load. If you take a look at Assembly.Load in a decompiler you will see that it performs some sanity checks before calling RuntimeAssembly.nLoadImage. We skip the sanity checks and call the internal function directly.Let us take a look at the code responsible for parsing the Base64 encoded method names.byte[] payload = new byte[0x1337]; int offset = 0; for (int i = 0x1338; i &lt; 0x1339; i++) { MethodBase baseMethod = InvokeMethod&lt;MethodBase&gt;(1274687369, 1074927592, new object?[] { i }, module); string name = GetPropValue&lt;string&gt;(4243846143, 1642051212, baseMethod); fixed (char* ptr = name) { \t int length = GetPropValue&lt;int&gt;(1845477325, 4202415711, name); for (int j = 0; j &lt; length; j++) { \t ptr[j] -= (char)(_methodCache.Keys.ToArray()[0] % 100 - 30); } byte[] data = base64FromCharPtr(ptr, length); InvokeMethod&lt;short&gt;(2132718223, 4285503295, new object?[] { payload, offset }, data); offset += data.Length; }}Note that 0x133X values are temporary placeholders and will be replaced after injection. The base64FromCharPtr delegate is dynamically initialized and resolved via HInvoke.All notable calls have been replaced with a call to the HInvoke handler, leaving only the return type as an obvious indicator of its purpose. It’s important to note that the return type cannot be relied upon because we can select any type we want as the generic parameter if the method does not have a return value. Before writing the final image to disk, the packer will also rename all members in the runtime to random Unicode strings, further obscuring the code.As described above, this code loops through all methods that contain payload data. It uses MetadataToken values to resolve the methods using Reflection. The first handler resolves the method the second handler retrieves its name. Then we get a pointer to the string and decrypt it char by char using a slightly obscured subtraction of 65, the numeric value of the uppercase A in the ASCII encoding. After decrypting the string, we use the dynamically resolved delegate base64FromCharPtr to convert the Base64 string back to bytes. The resulting byte array is then copied into the large array initialized at the top, which will later contain the entire payload image.var assembly = InvokeMethod&lt;Assembly&gt;(3909091325, 1082111880, info); //System.Reflection.RuntimeAssembly.nLoadImage var entryPoint = GetPropValue&lt;MethodInfo&gt;(4078926558, 3155696631, assembly); // System.Reflection.Runtime.EntryPoint object[] parameters = new object[InvokeMethod&lt;ParameterInfo[]&gt;(1891508174, 4164820959, null, entryPoint).Length]; if (parameters.Length != 0) parameters[0] = args; InvokeMethod&lt;object&gt;(1891508174, 4026509245, new object?[] { null, parameters }, entryPoint); // System.Reflection.MethodBase.Invoke(object, object[])After the image has been reconstructed, it is loaded into our AppDomain using nLoadImage. Next, the entry point is resolved and called, passing any command line arguments supplied to the loader stub to the payload. Support for dynamic libraries is not implemented since they do not have an EntryPoint property. Pull requests are always appreciated if you would like to add support for dynamic libraries.The Analysts PerspectiveNow let us take a look at a packed image produced by NixImports in dnSpy. Apart from reducing import references HInvoke also does a great job as an obfuscator. As we can see most of the code is made up of calls to HInvoke handlers. We can see some return types of the handler methods but no direct references to any functions. The renaming obfuscation applied makes the code even less readable.Most analyst’s first thought would likely be to run the binary through de4dot. However, de4dot would destroy the loader by renaming the methods containing the encoded payload bytes, a nice side effect increasing the difficulty of pure static analysis.By checking the Type References in dnSpy, we can evaluate the imported types and their members. This info can give some valuable insights into the capabilities of a program. Using HInvoke, we should not find any references to the methods and properties we accessed through its handlers. Let us check: Assembly is imported but only references GetTypes, with no references to dynamic assembly loading. The assembly contains no references to Convert which contains Base64 encoding-related methodsSuccess! The loader’s assembly is missing typical indicators that one would expect to be present in a loader. In case you want to use it or experiment with it yourself, checkout the GitHub repositoryTips for DefendersAfter discussing how NixImports operates, let’s now examine potential detection methods. The current implementation has a few flaws, that allow for static detection. A few indicators that come to mind when I thought about possible detection are: Hardcoded hash values used within the code The hashing algorithm itself Hardcoded encryption: We can search for known text values, since we know what they will be in their encrypted form.Based on these indicators, I created a simple Yara rule. The rule consists of two patterns. The first one represents the encoded MZ header of the payload . The second pattern covers the initialization of the delegate for Base64FromCharPtr, which happens right at the beginning of the loader code. The $a strings represent imports required by HInvoke.rule MAL_Msil_Net_NixImports_Loader { meta: description = \"Detects NixImports .NET loader\" author = \"dr4k0nia\" date = \"2023-05-21\" reference = \"https://github.com/dr4k0nia/NixImports\" strings: $op_pe = {C2 95 C2 97 C2 B2 C2 92 C2 82 C2 82 C2 8E C2 82 C2 82 C2 82 C2 82 C2 86 C2 82} // PE magic $op_delegate = {20 F0 C7 FF 80 20 83 BF 7F 1F 14 14} // delegate initialization arguments // Imports that will be present due to HInvoke $a1 = \"GetRuntimeProperties\" ascii fullword $a2 = \"GetTypes\" ascii fullword $a3 = \"GetRuntimeMethods\" ascii fullword $a4 = \"netstandard\" ascii fullword condition: uint16(0) == 0x5a4d and filesize &lt; 3MB and all of ($a*) and 2 of ($op*)}" }, { "title": "Analysing A Sample Of Arechclient2", "url": "/posts/Analysing-a-sample-of-ArechClient2/", "categories": "", "tags": "", "date": "2023-02-05 00:00:00 +0000", "snippet": "In this post, I will be going over my process of analyzing a sample of ArechClient2. Including initial analysis, deobfuscation and unpacking of the loader. Followed by the analysis of the .NET payload revealing its config and C2 information.It began with this tweet by @Gi7w0rm. They mentioned me and a few others asking for help analyzing this sample. I decided to look into the sample. After publishing some threat intel and a few updates on my re progress on Twitter, I decided to write this report for a more detailed documentation of my analysis. The original sample can be found here.Initial AnalysisThe sample consists of two files, an executable and an a3x file. After some quick research, I found that a3x is a “compiled” form of AutoIt script. The executables icon is the logo of AutoIt and the copyright information says it’s AutoIt. This leads me to believe that this executable is the runtime required to execute the a3x file.I ran the file in a Windows Sandbox, for some quick intel and immediately got a Windows Defender hit for MSIL:Trojan... which indicates that this AutoIt part is just a loader for a second stage .NET binary. In case you are not familiar with the terms, “MSIL” stands for Microsoft Intermediate Language, which is the bytecode that .NET binaries are compiled to.The a3x script is human-readable. So after putting it into Visual Studio Code I saw this.It looks pretty messy at first but taking a closer look I found something that stuck out: The calls to the function called DoctrineDrama look suspiciously like string decryption. So my next step was to find that function, I used the search function to look for it’s name until I found the actual implementation. All functions start with the keyword Func and end with the keyword EndFunc, making it easy for us to identify them. I copied the code of the DoctrineDrama function to a separate file. The code is obfuscated and seems to contain quite some junk code. My first step was to indent the code, for easier readability.Looking at the code, specifically the switch cases inside the loops, I realized that only the branches that use ExitLoop are of importance. Taking a look at the switch conditions confirmed that suspicion. At the beginning of the function, the second variable is the loop condition, it’s initialized with a value of 921021. Looking at the switch, it matches the case that exits the loop, meaning the other cases are dead code and can be ignored. I removed the dead branches, cleaned up the unnecessary loops and got rid of the unused variables:After cleaning up we are left with this code. Reading this we can deduce some more fitting variable names, the first argument seems to be the encrypted input, and the second argument is the key. The first variable is the resulting string. So to understand the rest of the code I looked at the documentation of AutoIt, the StringSplit function, takes the following arguments: A string, a delimiter char and an optional argument for the delimiter search mode. So the second local variable in DoctrineDrama is an array of strings split from the input. Next, the code iterates through all the elements of that array and appends a new character to the output string with every iteration. We see a call to a function called Chr, which according to documentation converts a numeric between 0-255 value to an ASCII character. But something is off, what is going on inside that call to Chr? subtraction on a string, how does that work? I wondered about that but after a quick web search, I found out that in AutoIt digit only strings seem to be auto-converted to a number if you perform any arithmetic operation on them. Once the loop is finished, the output string is returned.Looking at this fully cleaned-up version, I reimplemented the decryption routine in C# to build a simple deobfuscator.static string Decrypt(string input, int key){ var buffer = input.Split('h'); var builder = new StringBuilder(); for (int i = 0; i &lt; buffer.Length; i++) { builder.Append((char)(Convert.ToInt32(buffer[i]) - key)); } return builder.ToString();}The deobfuscator uses a simple regex pattern to match every call to DoctrineDrama and replace it with the decrypted string. It also outputs a list of all decrypted strings. The full deobfuscator code can be found here.Dumping the payloadAfter deobfuscating all the strings, I searched the string dump for some Windows API function names that I would expect from a loader. I found a few hits on NtResumeThread, CreateProcessW and NtUnmapViewOfSection. These three in combination give a huge hint towards process hollowing. After searching the string dump for .exe I found the suspected injection target \\Microsoft.NET\\Framework\\v4.0.30319\\jsc.exe, a utility of .NET Framework 4.x which comes with every standard Windows 10 install.My next step was to debug the executable using x64Dbg. I set a breakpoint on CreateProcessW, to ensure we break before the injection process is started. After running past the entry point I was greeted with this nice little message.The message box claims I violated a EULA which I never read nor agreed to. I guess we can’t debug the malware any further how unfortunate. Luckily for us, x64Dbg has a built-in AutoIt EULA bypass, it’s called Hide Debugger (PEB). You can find it under Debug&gt;Advanded&gt;Hide Debugger (PEB). Make sure to run x64Dbg in elevated mode.After dealing with the rather simple anti-debug, we let it run. When debugged, the executable spawns a file dialog asking for an a3x file, when run without a debugger it automatically finds the script file. After pointing it to the script file we let it run until the breakpoint for CreateProcessW is hit. At this point, jsc.exe will be started in suspended mode. Checking Process Explorer confirms that the decrypted path from the AutoIt script was indeed the injection target. We add another breakpoint on NtResumeThread which will break execution after the injection is finished but before the thread is resumed to execute the malware.Since we already know the malware is .NET-based I will use ExtremeDumper to get the managed payload from the jsc.exe process. Run ExtremeDumper as admin and dump jsc.exe, if it does not show up make sure you are using the x86 version of ExtremeDumper. At the time of writing the loader does not run anymore but fails with an error message about Windows updates. Sifting through the string dump I suspect there is some sort of date check that prevents further execution. This was likely implemented to prevent future analysis. Luckily I had dumped the actual payload before.The .NET PayloadAfter dumping the loader, I had to deal with the managed payload. The image is heavily obfuscated. I started my hunt in the &lt;Module&gt; class also referred to as the global type. I start by checking this class since its constructor is called before the managed entry point. Many obfuscators call their runtime protections or functions like string decryption here.My guess was correct, I found a string decryption method c in &lt;Module&gt; (token 0x06000003). The method reads the encrypted string data from an embedded resource and then performs a single XOR operation decryption on it. The key used for decryption is supplied via parameters, which leads me to believe that each string has a unique decryption key.After checking references to c it turned out that the decryption relies on flow-dependent variables. The calls to the decryption routine have encrypted arguments that are using several opaque predicates and global variables that are initialized and changed depending on call flow.This means we would have to emulate or solve all calculations required to obtain the local variables and global fields that are used by the expressions that decrypt the arguments of the call to our decryption method c. The additional dependency on call flow further increases the effort required since we would need to solve all calculations in every method in the correct order. Considering all this I ditched the idea of writing a static string decryption tool.Sifting through the binary I found quite a few similarities to Redline, both making use of DataContracts and async tasks for the separate stealer modules.One class in particular seemed interesting. After looking for networking related functions I found a class cj token 0x0200010C that connects to a server via .NET’s TcpClient. Looking at the code we can spot the use of another class called xj which seems to contain the IP and port number for the TCP connection. See line 155 tcpClient.Connect(xj.c, Convert.ToInt32(xj.a.d)Apart from that xj also seems to contain a URL that the malware accesses and downloads a string from, see line 168. Let’s take a closer look at xj token 0x02000107. It contains quite a few properties but the most interesting is the constructor.This looks like a potential config class. It initializes the properties used for the initial TCP connection and the string download we saw in cj, which is a good indicator that we are indeed looking at the malwares config. I placed a breakpoint at the end of the constructor. Since the string decryption method was still an issue the easiest way to get the strings was to run the binary and have it decrypt the strings for me. I debugged the executable using dnSpy until I hit the breakpoint at the end of the constructor. After the breakpoint hit we can view all the properties and fields values in the Locals window by expanding the this parameter.Here we see the C2 IP 77.73.133.83 and port 15647. We can also see a Pastebin link, that caught my interest: The paste contains another IP 34.107.35.186, potentially a fallback C2.Before debugging, I modified the string decryption method by adding a few lines to write every decrypted string to disk. This modification makes it so that instead of immediately returning the string it’s first passed to AppendAllText and written to a file of our choice.The dump revealed the same values that we found in the Locals window and a few more strings of interest. For example, we got a list of the paths that the stealer checks for potential credentials. The main targets of this stealer seem to be browsers, mail clients and game clients like Steam. This is similar to most mainstream stealers. You can view the full-string dump here.Speaking of strings, I noticed another similarity to Redline, the use of char array to string conversion at runtime. Although Redline in many cases does insert some additional junk into these arrays that is removed from the constructed string, using the Replace or Remove method.Due to the heavy obfuscation and the rather similar behavior to existing stealers, I decided to not investigate this payload further. We revealed the most important IOCs and got a pretty good understanding of the stealer’s targets.SummaryWe found that the initial loader was implemented in AutoIt and uses ProcessHollowing to load a .NET-based payload, we reconstructed the string decryption method enabling us to partially deobfuscate the loader. We dumped the managed payload using a debugger and ExtremeDumper. We analyzed and debugged the managed payload to reveal the payload config, containing the C2 information.After analyzing the string dump, I found some indicators that could help with attribution to a certain malware family. Although this sample does look very similar to Redline stealer, it is actually not part of that family. I found this blob of data that looked suspiciously like C2 communication:{\"Type\":\"ConnectionType\",\"ConnectionType\":\"Client\",\"SessionID\":\"\",\"BotName\":\"\",\"BuildID\":\"\",\"BotOS\":\"Caption\",\"URLData\":\"\",\"UIP\":\"\"}Referencing the above data and the port number to other writeups, like this one from IronNet Threat Research, revealed similarities to a different malware family. The screenshot below shows a network capture of an active ArechClient2 sample performed by the researchers from IronNet. Comparing this data we can conclude that our sample is also part of the ArechClient2 family.image sourceWith this we have reached the end of our analysis. Below, I have arranged all important IOCs, for the threat intel focused readers. I write these reports in my freetime and publish them for free, if you want to support my work feel free to sponsor me on GitHub.IOCs Description Indicator C2 77.73.133.83:15647 Potential Fallback C2 34.107.35.186:15647 URL for fallback C2 https://pastebin.com/raw/NdY0fAXm .NET payload Test.exe SHA256: a835602db71a42876d0a88cc452cb60001de4875a5e91316da9a74363f481910 AutoIt loader 45.exe SHA256: 237d1bca6e056df5bb16a1216a434634109478f882d3b1d58344c801d184f95d AutoIt script S.a3x SHA256: 8e289b8dfc7e4994d808ef79a88adb513365177604fe587f6efa812f284e21a3 " }, { "title": "Unpacking RedLine Stealer", "url": "/posts/Unpacking-RedLine-Stealer/", "categories": "dotnet, reverse-engineering, malware", "tags": "", "date": "2023-01-04 13:27:24 +0000", "snippet": "In this post, we are going to take a look at Redline Stealer, a well-known .NET based credential stealer. I will focus on unpacking the managed payload and extracting it’s config, for a more detailed analysis of the payload you can check out this post by c3rb3ru5d3d53c.Dealing with the native dropperMany of the in-the-wild samples of Redline are plain .NET applications with pretty basic custom obfuscation. Considering that many commonly used obfuscators lead to false positive AV detections this is very likely intentional. Although primarily using .NET, many samples come packed in a native x86 wrapper that will load the managed payload at runtime. Unpacking this native dropper is quite simple, it uses process hollowing on a legitimate process. We can use this to our advantage; since the injection requires the process to be started in suspended mode we can simply use a debugger to pause the execution before the process is unsuspended and dump it. The injection target might vary between versions. In my case, they inject into AppLaunch.exe which is a utility binary of .NET Framework 4.0+, that is part of the standard Windows 10 install.The dropper dynamically resolves the functions required for process hollowing. So we will not find them in the imports but there are some artifacts from gcc’s error handling which give a hint as to which functions are used. Strings like “VirtualProtect failed…” make it easy to guess what is going on even if the actual functions are dynamically resolved. The following functions are used:CreateProcessWReadProcessMemoryVirtualProtectNtWriteVirtualMemoryNtSetContextThreadNtResumeThreadNtUnmapViewOfSectionIt then performs simple process hollowing. Which we can simply dump. For this, I use x32Dbg, and set a breakpoint on NtResumeThread then continue execuction. Once the breakpoint hits I dump the AppLaunch.exe process, that was spawned by the dropper, using ExtremeDumper to get a perfectly working managed image from the process. Make sure to run ExtremeDumper as Admin to find the AppLaunch process. Once we have the dumped image we can simply terminate AppLaunch.exe and our debuggee.Dealing with the managed partMost of Redline’s obfuscation is focused on the strings. Not all strings are obfuscated but most of the characteristic ones are, especially strings that can be used to detect the malware. These obfuscated strings are constructed at runtime from a char array and in some cases, they have random text inserted that will be removed from the string before it’s used.Since this was quite annoying to get rid of manually for the whole binary I decided to write a custom tool. The tool is pretty simple, it consists of two clean-up stages. The first one is to remove the array to string assignments And the second one is to clean the inserted text and replace operations. I also added a stage for config extraction which will be discussed later. As per usual I came up with a fun name for this tool: It’s called Greenline.Deobfuscating the stringsWe begin by searching for all string constructors that take a char array as it’s parameter and are preceded by a call instruction. The constructor is called using a newobj instruction, with the constructor as it’s operand. The constructor requires a char array to be pushed on the stack before its executed. Lets look at what the code we are dealing with looks in CIL:IL_0000: nopIL_0001: ldc.i4.5IL_0002: newarr System.CharIL_0007: dupIL_0008: ldtoken &lt;PrivateImplementationDetails&gt;::DC0F42A41F058686A364AF5B6BD49175C5B2CF3C4D5AE95417448BE3517B4008IL_000d: call System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array, System.RuntimeFieldHandle)IL_0012: newobj System.String::.ctor(char[])The first thing that happens is the array initialization. At IL_0001 the size of the array is pushed on to the stack as an integer, next a new array of type char is initialized. For the next part I need to explain how arrays in .NET are actually stored.For value type arrays like char, byte etc. that are initialized inline and have more then three elements the compiler will generate a ![](new type named &lt;PrivateImplementationDetails&gt;. The type contains fields that point to chunks of bytes within a data section of the PE. These fields are of a struct type with a hardcoded size, telling the runtime the size of the chunk. At runtime, the System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray method is called to perform a memory copy of the data referenced by the field into the array’s memory location.After the array has been initialized it is consumed by the System.String constructor at IL_0012. Since this CIL pattern can in some cases be different or deliberately altered by an obfuscator I decided to use Echo1, a framework with data flow analysis capabilities for CIL. With Echo we can reliably resolve the dependencies of the call to InitializeArray.In this snippet we can see that the string constructor call is preceded by a call to InitializeArray. This call depends on a couple more instructions. First an array object, which is made up of the instructions from 0020 to 0022 the size of the array which is 19 then the type of the array object char. The dup copies the top most stack item which is the array object and pushes it on top of the stack again, which is later used by the string constructor. Next ldtoken pushes the handle to the field in &lt;PrivateImplementationDetails&gt; onto the stack. So now we have everything our call depends on. Echo can find these kind of dependeny relations automatically, using a symbolic flow graph to obtain all instructions that are required by a consumer like the call in the example.Using the obtained dependencies we can manually construct the string and patch the old CIL with just a string assignment, replacing all no longer needed instructions with NOP’s.The second stage follows the same logic, but this time we search for all calls to the Replace method using two string literals as arguments. We use Echo to obtain the dependencies and patch all no longer needed instructions with NOP’s leaving us with the final deobfuscated string.Extracting the configThis part is probably the most interesting for the more threat intel focussed readers :D. Identifying the config of Redline is pretty simple when we have easy access to the managed types and their members. I use an exclusion-based search, iterating through the types we abort processing for all types that don’t match our criteria. A few identifiers that I use to find the correct class: Is a public static class Has a static constructor and 5 fields (the constructor is hidden in the C# view, it initializes the fields with the values seen in the decompilation) Has the custom attribute System.Reflection.ObfuscationAttribute (Has a field named IP)After we find the correct class we obtain all field values by parsing the static constructor of the class, which initializes the fields. The C2 IP and the ID are XOR encrypted and Base64 encoded so we need to decrypt and decode them for that, I simply copied and simplified the decryption routine from Redline. After we decrypted the encrypted fields we have a fully readable config.ConclusionI hope you found this little post helpful and can put it to use analyzing Redline Stealer. The tool described in this post and it’s source code are available on my GitHub, feel free to check it out. If you’re interested in .NET deobfuscation in general make sure to check out the code as it’s basic approach can be adapted for other obfuscation of this kind as well.Samples x86 compiled binary: modest-menu.exe, SHA256:0d753431639b3d2b8ecb5fb1684018b2c216fec10cc43d0609123f6f48aa98b8 Unpacked child =&gt; .NET binary: Bahut.exe SHA256: 98d146faabd764f5ddd4a2088dfaf075dd382358026498344c91dcb46a7dff66 .NET binary: file, SHA256:714AE901F55DB2580AC4AC9048C09EFDCD562F301640A6FD8343293F1EBB36FF .NET binary: PEInjection.exe, SHA256:465FBA168502ED66E373DB521F1C0DD93CE30E69D271528051390817977B4818 Developed by Washi1337, Echo is an experimental generic static analysis, symbolic execution and emulation framework. &#8617; " }, { "title": "String Obfuscation The Malware Way", "url": "/posts/String-Obfuscation-The-Malware-Way/", "categories": "dotnet, coding, malware", "tags": "", "date": "2022-12-15 19:27:24 +0000", "snippet": "Malware authors like to use string obfuscation to make their code harder to analyze and detect. One obfuscation technique is to insert special characters into a string, and then use some code to remove those special characters at runtime. This technique is simple but effective, as it can hide the actual string from being easily identified.I recently came across an example of this technique on Twitter. So I thought, I will build my own version of this obfuscation and open-source it. For this, I revived an old project that followed the same concept but uses primarily homoglyphs. Homoglyphs are characters that look similar to alphabetical characters but are actually from a different alphabet.While this technique is not as secure as encryption, it can still be useful for malware authors who want to avoid detection by simple string analysis and other static analysis techniques. Not encrypting or encoding the strings will also help avoid entropy-based detections.As you might know, I have a minor obsession with fun names for my projects, so this time I came up with the name MurkyStrings, why? Well, we obscure strings by adding random characters which are just like fog, making the strings murky. Anyways let’s dive into the code :DAbusing string replaceThe main idea is to insert a few different homoglyphs into the original strings to confuse reverse engineers and obfuscate the true content of the string. The inserted characters will then be removed on runtime using a method from C#’s String class. Here is an example of the decompilation results:As you can see we are using a variety of homoglyphs that look exactly like the normal alphabetical characters. To make the whole thing a little more confusing to the human eye I did make sure that all homoglyphs I use are emitted right after or before the corresponding alphabetical character.So a normal 'a' in the string will be followed or led by a Cyrillic 'а' and so on. Any other character will result in a random available homoglyph being emitted. See the following function for reference:private char GetHomoglyph(char input) { char[] glyphs = {'а', 'е', 'і', 'о', 'с'}; switch (input) { case 'a': return glyphs[0]; case 'e': return glyphs[1]; case 'i': return glyphs[2]; case 'o': return glyphs[3]; default: return glyphs[_random.Next(glyphs.Length)]; }}To implement the above we parse all methods specifically their method body going through the instructions one by one and matching on Ldstr instructions. When we find a string assignment we take its operand as the target string and insert the homoglyphs as discussed before.After we inserted all the homoglyphs into the string, we need to add the code that will remove them on runtime. We insert an Ldstr isntruction that pushes the homoglyph we need to replace. Next, we insert an Ldnull instruction, which we do so the homoglyph is replaced with nothing. At last, we insert a Call instruction to System.String.Replace(System.String, System.String). We repeat this three-instruction pattern for all available homoglyphs, but instead of a Call, we emit a Callvirt instruction for all following replacements.The result of this can be seen in the decompiled code shown earlier.I have also included an option to use a simpler form of replace abuse. In this simpler mode, only one special character is used to obscure the strings, we insert a random amount of these special characters for each character of the target string. This way we need to call Replace only once, saving us a lot of allocations. Since strings are immutable in .NET any changes to an existing string will result in a new string being allocated.Abusing string RemoveAnother idea that follows this concept is inserting random text or names into strings and using the Remove method to remove them again at runtime. To achieve this I parse method names from the System namespace and insert multiple of them into the strings to be obfuscated. Afterward, we inject some CIL again. The injected CIL will remove the inserted text and consists of three instructions per insert. Two Ldc.I4 the first being the start index and the second being the length to be removed. During the obfuscation of the original string for every added text we saved the index at which it was inserted and the length of it. Thus we can simply injected it with the CIL. The last instruction is again a Call or Callvirt with System.String.Remove(System.Int32, System.Int32) as its operand. This method removes everything between the given starting index and the length from the string.The resulting decompilation will look somewhat like this:The inserted names are parsed directly from the System namespace, concated together, and randomly inserted into the target string, with occasional spaces to further obfuscate the actual content. However there are a few issues with this method: For example, one of the randomly inserted method names might be a name that would be considered suspicious by an AV/EDR or analysis tool. Another problem is that the inserts might not overlap with an important part of the target string, revealing parts of the original content. To improve this, we could use a dictionary of known inconspicuous names, or generate random strings. Since the code is open source you are free to change the code to your liking/needs.Stacking both techniquesBoth of these techniques work great on their own but what if we combine them? Well, it gets pretty messy but works just fine. By applying the homoglyphs after the removal obfuscation we also eliminate the risk of any of the inserted method names being flagged. Additionally, these combined strings are much less humanly readable. Check the following screenshot for the decompilation results:You should however keep in mind that this will result in quite a few allocations since we modify the string multiple times. For a simple loader etc. this will not have a meaningful performance impact therefore it can be neglected.Closing wordsI hope you enjoyed this post, and maybe have learned something or found a tool for future use.Checkout the full source code of the project on GitHub" }, { "title": "Encrypting strings in .NET", "url": "/posts/Encrypting-Strings-In-NET/", "categories": "dotnet, coding", "tags": "", "date": "2022-10-15 19:27:24 +0000", "snippet": "Implementing custom string encryption for .NET binaries utilizing an XOR-based cipher and AsmResolver. Encrypting strings is a common practice to slow down static analysis or evade automatic analysis, in this blog post I will explain how I build my own binary-level string obfuscator in C# .NET 6. The full code of the project can be found here.Concept and StructureTo begin with, I will explain the concept of my implementation. The following points had to be considered: A unique XOR key per string Only one universal decryption method The decryption method should have as few parameters as possible Parameters of the decryption method should be encrypted or encodedIn order to include a unique XOR key per string and reduce the number of parameters needed for the decryption method, some metadata is required. The metadata per string includes the length of the encrypted data and the XOR key to decrypt that data. Using this format all data can be stored in one single data blob. To get a string from the data blob we only need the offset at which the formatted data starts. From that offset, we parse the metadata reading the length first and then the XOR key.Additionally to the string data, another XOR key in form of an int is added to the beginning of the data blob. This key serves as the global XOR key used exclusively to decrypt parameters passed to the decryption method. Offset Size Field Description 0 4 Length Length of the encrypted Data 4 4 Key Key to XOR decrypt Data 8 n Data Encrypted Data This table shows how each encrypted string and its metadata are stored in the data blob. First the 8 bytes of metadata then the encrypted string data.My implementation is split into two projects. First, the runtime, which handles the decryption and stores the encrypted data in the obfuscated binary. The second part is the obfuscator, it injects the runtime into the target binary and handles encrypting the strings as well as rewriting the CIL code to use the string decryption.The RuntimeStarting with the runtime, the part responsible for decrypting strings in the obfuscated binary. I will be using an initialized struct for data storage, basically putting raw byte data into a struct. This method is quite appealing for obfuscation since dnSpy and other decompilers by default only show a field and an empty struct with a fixed size but not the raw content. This means locating the encrypted string data is slightly harder in a standard .NET decompiler.The before-mentioned struct and decryption routine are part of the runtime project which is compiled using netstandard 2.0 to ensure compatibility with .NET Core and Framework at the same time. Since we do not know the contents of the struct before encrypting strings I use an empty placeholder struct which will be patched later by the obfuscator.Let us take a look at the decryption routine first:public static string Decrypt(int id){ if (id &gt;&gt; 31 != 0) return string.Empty; byte* data = (byte*) 0x420; data += id ^ *(int*)data; byte[] buffer = new byte[*(int*) data]; fixed (void* ptr = &amp;buffer[0]) { cpblk(data + 8, ptr, (ulong) buffer.Length, (ulong) buffer.Length); } int n = buffer.Length - 1; for (int i = 0; i &lt; n; i++, n--) { buffer[i] ^= buffer[n]; buffer[n] ^= (byte)(buffer[i] ^ *(int*) (data + 4)); buffer[i] ^= buffer[n]; } if (buffer.Length % 2 != 0) buffer[buffer.Length &gt;&gt; 1] ^= (byte)*(int*) (data + 4); // x &gt;&gt; 1 == x / 2 return string.Intern(Encoding.UTF8.GetString(buffer));}// Placeholder for cpblkprivate static void cpblk(void* destination, void* source, uint bytes){ throw new NotImplementedException();}At the beginning, it verifies that the provided id parameter is a non-negative value. This is done because in the obfuscator empty strings are replaced with calls to the decryption method but instead of a normal value, a negative value is supplied. Empty strings cannot be encrypted with the current logic hence this exception was added.The variable data is assigned a placeholder value, for now. It will later be patched by the obfuscator with the address of the initialized struct.To find the encrypted string in the data blob the id parameter is decrypted using the global XOR key, which is located at the beginning of the data blob. The decrypted result is the offset at which the encrypted string alongside its metadata is located. The offset is then added to data the base pointer for the raw data.Next, a new array is initialized acting as a buffer for the encrypted string data. The size of the buffer is read from data by casting it to an int pointer and dereferencing it. Since data points to the first value of the string format, which is the length of the encrypted string in bytes.Using cpblk the encrypted string bytes are copied into buffer. The address to copy from is data with an offset of 8 added, due to the length and the XOR key stored in front of the string data each taking up 4 bytes. The amount of bytes copied is equal to the length of buffer.The cpblk1 placeholder method will later be replaced by the obfuscator. It serves as a placeholder for the CIL instruction cpblk which has no C# implementation and can therefore only be used by patching or manually constructing CIL code.After copying the encrypted bytes to buffer they have to be decrypted. Using a loop with 2 indexing variables i, which starts at index 0, and n, which starts at the last element of buffer. While i increases with each iteration n decreases with each iteration. Using the XOR swap algorithm on the elements at index i and n in the loop we reverse the order of bytes in buffer.At the same time, the swapped byte is decrypted using another XOR with the unique string key which is read by casting data with an added offset of 4 to an int pointer and dereferencing it. Since the loop does not account for the “middle” byte of odd element count arrays, a check was added to decrypt said byte. First using remainder to check if the element count of buffer is odd if that is the case get the byte at the index, length of buffer right shifted by 1 (equivalent to diving by 2). Then XOR decrypt the byte at said index with the unique string key just like in the loop.Finally, use Encoding.UTF8.GetString to convert the decrypted buffer into a UTF8 formatted string. With string.Intern to take advantage of the .NET runtimes string caching capabilities.The ObfuscatorWe will use two classes first the StringEncryption class, which is the main part of the obfuscator responsible for parsing the .NET target binary using AsmResolver. The second class we will use is the EncryptionService class which handles encrypting the strings and stores the encrypted data until it is injected into the target binary.In the StringEncryption class, we start by injecting the runtime. Using AsmResolvers MemberCloner to clone the decryption method from our runtime DLL into the target binary. We resolve the injected decryption method, and the placeholder for cpblk and store the resolved methods for later use.After we injected the runtime, we go through all types that have any methods. Next, we iterate over all methods, skipping methods that don’t have a CilMethodBody. Now we can iterate over the CIL instructions and filter out only Ldstr instructions. Once we find a Ldstr instructions we will need the EncryptionService class. It handles the encryption of strings and stores all encrypted Data. It has three properties: Property Description Index Encrypted version of the current offset in the encrypted data blob Length The total length of the encrypted data in bytes. Data The encrypted data as a byte array. If the operand of the Ldstr instruction is an empty string, we do not encrypt it but instead patch the instruction with an Ldc.I4 that has the negated value of Index as operand. We negate the value since the runtime identifies empty strings by negative values and handles them in the special way discussed in the first part. After we patched the Ldstr instruction we insert a call instruction with the injected decryption method as its operand.After processing all methods we need to do some patches in the injected runtime. First, we need to set up the placeholder struct with the correct attribute values. The struct needs a ClassLayout with packing size 1 and the length of the encrypted data as its size.We also need to create a new field which will be an initialized version of our struct. By adding a DataSegment in its FieldRva, we can use the field to store any raw data we want, in this case, our encrypted string data.The last part is patching the placeholder values in the decryption method. For that, we will resolve the Ldc.I4 instruction that has 0x420 as its operand and patch it with a Ldsflda instruction that has our field as its operand. Ldsflda will push the address of the field on the stack. Since the field holds our data the pushed address will point to the base of our encrypted data blob.Additionally, we also need to patch the placeholder for cpblk for that we simply resolve the call instruction which has the placeholder method as its operand and replace it with a cpblk instruction. We can then remove the placeholder method since it is no longer required.Once we have replaced all placeholders and removed the unused method, we can write the modified target binary to disk. You now have a binary with fully encrypted strings. MS Documentation for cpblk &#8617; " }, { "title": "Unpacking OriginLogger Builder", "url": "/posts/Unpacking-OriginLogger/", "categories": "dotnet, reverse-engineering", "tags": "", "date": "2022-09-20 14:46:24 +0000", "snippet": "Unpacking OriginLogger BuilderOriginLogger is a keylogger that shares a lot of similarities with the well-known Agent Tesla malware. Today I will take a look at their builder and unpack it. A little spoiler the sample used in this post was protected with a trial version of the commercial obfuscator Eazfuscator.NET which stops the binary from running due to the expired trial version…You can find the sample on malshareInitial AnalysisOpening the sample in dnSpy will show a lot of errors in the decompilation. Looking at the IL will reveal some invalid code. This is an indicator of method body encryption. Looking at the module constructor verifies that assumption. The first method called by the constructor at token 0x06000006 is responsible for decrypting the method bodies.Looking at the method we can quickly deduce what it is approximately doing. It starts with obtaining the HINSTANCE of the current module. Which is a pointer to the base of the currently loaded module aka the PE header base. To that pointer, it adds 0x3C which points to e_lfanew a field in the PE header which holds the file address of the new executable header. The value of e_lfanew is added to the base pointer and then used to read another value by adding offset 0x06 which points to NumberOfSections. The number of sections is stored in a local for later use. Next, it reads from offset 0x14 which points to SizeOfOptionalHeader this is important since the size of this part of the PE header varies depending on bitness. Using the size and offset 0x18 which points to the beginning of the section table. From there the code loops through the section table entries to find its custom PE section in which the encrypted method bodies are stored. It will then decrypt the method bodies. (I shortened this explanation due to time constraints)DumpingTo get the unencrypted method bodies, I will debug and dump the file. Start by placing a breakpoint on the second call in the global module constructor. We can safely ignore the anti-debug code in the method decryption routine since dnSpy by default hooks CheckRemoteDebuggerPresent and IsDebuggerPresent to avoid detection.Once the breakpoint hits open the Modules tab and right-click the main module. Save it to disk.Now open the saved module and patch both calls in the global module constructor with a NOP instruction, since we don’t need to decrypt methods anymore and the second call is runtime anti dump which we also don’t need. Save the changes.DeobfuscatingNext, we will use de4dot to get rid of the Unicode names. Simply drag &amp; drop the dumped and patched binary into de4dot and let it do its work. After de4dot has finished we are left with the string encryption for that we will use a tool called eazfix make sure to use the --keep-types argument. Eazfix will decrypt the strings for us, if you’re curious how it works it uses Harmony to patch the stackframe calls used by Eazfuscators string encryption. After patching the stackframe method to always return the string decryption method it can simply invoke the string decryption routine for each string and patch the call with the resulting string.As soon as eazfixer is done you have a fully unpacked Origin Loader sample ;)" }, { "title": "HInvoke and avoiding PInvoke", "url": "/posts/HInvoke-and-avoiding-PInvoke/", "categories": "dotnet, coding", "tags": "", "date": "2022-08-10 19:27:24 +0000", "snippet": "A very minimalistic approach of calling .net runtime functions or accessing properties using only hashes as identifiers. It does not leave any strings or import references since we dynamically resolve the required member from the mscorlib assembly on runtime.How does HInvoke work?Its fairly simple, iterate trough all Types of mscorlib and hash their names using some hashing function. Upon finding the matching type continue by iterating trough all its methods or properties and do the same hashing routine as before. Finish by either invoking the resolved method and if applicable return its returnvalue or return the value of the resolved property. This whole process has one fairly big limitation it can only find methods that have a unique name, as the current implementation is fairly lazy and does not take parameter count or types into account. public static T InvokeMethod&lt;T&gt;(uint classID, uint methodID, object[]? args = null) { // Get the System assembly and go trough all its types hash their name // and find the hash that matches the supplied one var typeDef = typeof(void).Assembly.GetTypes() .FirstOrDefault(type =&gt; GetHash(type.FullName!) == classID); // Use the type and go trough its methods hash their name // and find the hash that matches the supplied one var methodInfo = typeDef.GetRuntimeMethods() .FirstOrDefault(method =&gt; GetHash(method.Name) == methodID); // Invoke the resolved method with the supplied args if (methodInfo != null) return (T) methodInfo.Invoke(null, args); return default!; }Calls using HInvoke look like this if (HInvoke.GetPropertyValue&lt;bool&gt;(1577037771, 179842977)) // System.Diagnostics.Debugger.IsAttached HInvoke.InvokeMethod(1174404872, 2029614223, new object[] {0}); // System.Environment.Exit(0)The HInvoke call requires the two before mentioned hashes, and additionally parameters for the method being called. The example is a common anti debug measure in .net obfuscators, only that this version does not expose the actual call on first glance. It checks the value of Debugger.IsAttached in case its true it calls Environment.Exit with parameter 0, closing the program.So in short: We can call every uniquely named method from the .net runtime using only 2 hashes.Avoiding PinvokeAnother idea I got while browsing trough the internal parts of the managed .net runtime. There is a class called Microsoft.Win32.Win32Native which contains you guessed it managed wrappers for native functions. Since Microsoft already so kindly provides these wrappers it would be a waste to not use them.There were 2 functions that I found especially interesting: GetModuleHandle and GetProcAddress. By invoking them we can without any usage of PInvoke in our binary get the address of any unmanaged function. Also by using the delegate pointer type (delegate*) we can easily invoke the resolved unmanaged functions. var module = HInvoke.InvokeMethod&lt;IntPtr&gt;(13239936, 811580934, new object[] {\"kernel32.dll\"}); // Microsoft.Win32.Win32Native.GetModuleHandle var address = HInvoke.InvokeMethod&lt;IntPtr&gt;(13239936, 1721745356, new object[] {module, \"IsDebuggerPresent\"}); // Microsoft.Win32.Win32Native.GetProcAddress if (((delegate* unmanaged[Stdcall]&lt;bool&gt;) address)()) Console.WriteLine(\"Hey meanie I said no debugging :c\");The example shows a combination of using the Win32Native class and HInvoke to resolve the address of kernel32!IsDebuggerPresent. After it casts a delegate pointer with the unmanaged attribute, the calling convention and the returntype on the resolved address. Then calls it.You can find the full example code hereThis is a rather short post but hopefully interesting to some. For feedback or questions contact me on Twitter or Discord." }, { "title": "Some thoughts on making a crackme", "url": "/posts/Some-thoughts-on-making-a-crackme/", "categories": "dotnet, reverse-engineering", "tags": "", "date": "2022-01-25 22:13:24 +0000", "snippet": "In the last few weeks, I’ve been taking a closer look at crackmes, especially beginner focused ones. And noticed a few things that I think many new developers get wrong. Therefore this is a little bit of personal advice for beginner crackme challenges. I will only focus on C# code in this write up however some of the ideas apply to other languages as well.What is a crackme?A crackme is usually a reverse engineering challenge that implements some kind of vulnerable key/password verification system. The task for the user is to circumvent or reverse engineer the system to either login successfully or access a hidden flag. There are different formats of these challenges out there but I will mainly focus on the before mentioned formats.Do not rely on clear text key comparisonsA lot of people use very simple checks like a clear text string comparison with a hardcoded key. Instead of a more sophisticated check, they then rely on heavy obfuscation. The issue with that is, the check itself is still just a clear text comparison. This means no matter how heavily obfuscated the code is, the actual key will be in memory when it gets compared to the user input. Which makes solving them quite trivial. I will be focussing on challenges that use the string equality comparer to check user input against a hardcoded password usually stored in encrypted form.Using a debuggerA very simple way to defeat a challenge that relies on a simple string comparison is using a debugger like dnSpy. In many languages, string comparisons are implemented using a function or a method, and .NET is no exception. Therefore, you can place a breakpoint on the method responsible for string comparisons. When the method gets called during the key verification all you need to do is wait for your breakpoint to hit and read the used parameters in the locals window. In my example, I placed a breakpoint on the == operator in mscorlib System.String which is used in most crackmes that implement the previously described process. If you want to catch all string equality comparisons I would recommend placing the breakpoint on string.Equals instead.Now some challenges use anti debugging code to prevent dynamic analysis like this. Luckily for us dnSpy already can circumvent basic debugger detection. For example, it prevents detection via the System.Diagnostics.Debugger class, kernel32!IsDebuggerPresent and kernel32!CheckRemoteDebuggerPresent. There are also other ways to detect debuggers, one very commonly used technique is calling ntdll!NtQueryInformationProcess to check the ProcessDebugPort which will be non-zero when the process is run under a debugger1. However, quite a lot of people seem to fail at the implementation level. In many cases, I encountered anti debugging code that only runs once in the module constructor which makes it really ineffective since we just need to wait for the debug detection to run at the beginning, after that we can attach our debugger without any issue.Method HookingSay we encounter an app that has properly implemented anti debugging and patching would be inconvenient due to anti-tamper measures. It can therefore be difficult to rely on a debugger alone. Instead of a debugging, we can also hook the string equality comparer and intercept the parameters. To prove how easy this is I wrote a tool that should work on most challenges that rely on string equality comparisons. You can view the full source code here.The tool works by loading the crackme executable using Reflection. Once we loaded the executable, we can place our hook on string.Equals and invoke the entry-point of the executable. Since the Reflection loading part is quite boring I will not go into much detail and focus only on the hooking part.I am using the Harmony library for hooking. So to get started we initialize a new Harmony instance which will allow us to perform hooks and patches on our current AppDomain. We will use the Harmony instance to apply a patch to the string.Equals method, specifically a prefix hook. Prefix hooks are executed before the hooked method is executed, which allows us to intercept and modify the parameters.By calling Patch from our Harmony instance we install the hook. All following calls to string.Equals will now be processed by our callback before the actual method is called.Lets take a look at the callback code.private const char Key = '§';[HarmonyPatch(typeof(string), nameof(string.Equals))] public static bool Prefix(string a, string b){ // Skip invalid input if (a is null || b is null) return true; // Skip empty strings if (a.Length == 0 || b.Length == 0) return true; // Skip if none of the inputs starts with § if (a[0] != Key &amp;&amp; b[0] != Key) return true; // Take the value that does not start with Key string solution = a[0] == Key ? b : a; Console.BackgroundColor = ConsoleColor.Green; Console.ForegroundColor = ConsoleColor.White; // Print out solution and write it to file Console.WriteLine(\"Solution: {0}\", solution); File.WriteAllText(\"solution.txt\", solution); return true;}The method has a HarmonyPatch attribute which is required by Harmony to specify that a method can be used as a patch. The callback accepts two strings just as the original method. We will need to do a null check first since the supplied parameters can be null. If the null check hits or the one of strings is empty we return true. If we return true in a Harmony prefix hook it will skip the rest of the callback code and invoke the original method instead2. The last check is to make sure we only print out the intercepted parameters when our specified char '§' was supplied as input. This means that you have to enter § in the crackme when using the tool. I choose the § character since it is a rather uncommon character so we can be pretty certain that if a string starts with that char it is our input. Our input will be compared to the actual password which is why the string that does not start with § should be the solution. Once we found our potential solution we print it in the console and also write it to disk.DeobfuscationAnother technique to defeat a clear text key comparison is plain old deobfuscation. Since the key is present in the binary one way or another we can just try to find the method responsible for decrypting or constructing the string and get its result so we can read the actual string directly in the decompilation. Luckily for us, there is a great tool called de4dot. We can leverage de4dot’s emulator and clever Reflection usage to decrypt strings. We just need to provide de4dot with the information on what the decryption methods are so it knows what to emulate and invoke. To get that information we will need to do some manual analysis first. To make de4dot decrypt the strings we want, we need to supply it with the metadata tokens of the decryption methods. We can find these tokens using dnSpy.After obtaining the token we can use de4dot’s command-line arguments to make it decrypt all occasions of the decryption method we found. See the example below:de4dot &lt;path to crackme executable&gt; --strtyp delegate --strtok 0x06000004If there are multiple decryption methods you can simply append --strtok 0x06000000 to the arguments for each decryptor token. Since writing out command-line arguments every time can be a bit annoying I made a little GUI app that will construct the arguments and run de4dot for us. Usage should be self-explanatory, drag &amp; drop the executable you want to process. Select a decryption mode: delegate or emulation. Enter the decrypter tokens. And press the “Deobfuscate” button to make de4dot do its work. The tool can be found here.Writing a simple crackme that does not rely on clear text comparisonsWhat can we do instead of just comparing the user input to our password/key? My suggestion is to encrypt the user input using a deliberately vulnerable cipher, and compare it to the actual key that is stored in an encrypted form. This way we do not expose the clear text key as it is only compared in encrypted form, this means it cannot simply be obtained by placing a breakpoint on or hooking the string equality comparer. The key can be decrypted, however the actual decryption method is not present in the application. Which means a reverse-engineer would have to reconstruct the decryption routine based on the encryption routine. Keep in mind that the cipher used for encryption has to be vulnerable so it can be reversed, or brute-forced if that’s the objective you’re after.I will be implementing my example as a console application. The code is written in .NET 6 using the new template.Console.WriteLine(\"Enter the correct password:\");string? solution = null;while (solution == null){ string? input = Console.ReadLine(); solution = Verify(input);}Console.WriteLine($\"The password is: {solution} Good job :)\");I am not a fan of crackmes that just kill the process or break if you enter an incorrect password. Therefore I implemented a while loop to run as long as no correct key was entered instead. I use a nullable string variable as the loop condition, in the Verify method I only give out a non-null value when the password is correct. This is only the main method the actual interesting part is the verification method so let’s take a look at that next.static string? Verify(string? input){ // Skip any checks if the input is invalid if (input == null) return null; // This is our key in encrypted form char[] secret = { 'ä', 'ù', 'å', 'è', 'î', 'æ', 'î', 'Õ', 'Ý', 'è', 'þ', 'Ñ', 'ì', 'ø', 'â', 'ù', 'Ì', 'ù', 'Ö', 'É', 'æ', 'Ç', '×', 'Û', 'Þ', 'ā', }; // hint that the password is the same length as secret if (input.Length != secret.Length) return null; // Buffer that will hold the encrypted form of input char[] buffer = new char[input.Length]; // Encrypt the user input for (int i = 0; i &lt; input.Length; i++) { char c = input[i]; c += (char) 0xEA; c ^= (char) 0x7E; c -= (char) (0x5B + i); buffer[i] = c; } int sum = 0; // Compare the encrypted user input to secret for (int i = 0; i &lt; buffer.Length; i++) { sum |= buffer[i] ^ secret[i]; } if (sum == 0) return input; // Return null if input does not match secret return null;}We start with some basic checks that will abort the actual check if the key is null or not the correct length. The length check is already a hint to the reverser that the input needs to be the same length as secret. After these basic checks, we do some simple encryption using input. We iterate over each character of input performing some calculations then writing the result to buffer. We compare the encrypted result that is stored in buffer with secret, which is our password encrypted by the same cipher. We do that by defining the integer variable sum which is zero. We do a loop and XOR each char of buffer with the char at the same index in secret, since a number xored with itself is always zero the result will be zero if the characters match. We take the result to perform a logical OR operation with sum, which will change the value of sum should the result be non-zero. If buffer equals secret the value of sum stays zero and we return the value of input which will end the while loop seen in the main function and output the solution. If they do not match we simply return null and the while loop continues.Now how would you reverse engineer this if the password is encrypted?Lets think of the logic in Verify again: Get Input → Encrypt Input → Compare encrypted version of input with secret → Return resultLooking at this we know that secret has to be encrypted in the same way as buffer which means we know how the encryption works. But how do we use this knowledge? Let’s take a closer look at the encryption it uses addition, subtraction, and XOR. All of these operations are reversible which means we can calculate the original password by reversing the operations performed for encryption. So first we will need to reverse the order of the operations meaning first the subtraction then the XOR and finally, the addition since we are doing the process backwards. We also need to convert addition and subtraction to their counterparts, meaning we need to add 0x5B + i and subtract 0xEA to get the original value. The XOR algorithm works for encryption and decryption so we do not need to change it.What would the code to decrypt secret look like? Well, this I leave as an exercise to the reader :) The full code of the crackme example can be found on my gist. If you have any questions or want to show me your solution you can reach me on discord: drakonia#1110This example is of course really basic and not secure. But it is only meant to give you an idea of how to write a crackme that does not use clear text comparisons. You can easily improve this by increasing the complexity of the cipher or making the key verification happen in multiple steps etc. You are free to do whatever you want! But if you use a format like this keep in mind that the cipher has to be reversible somehow. A great way to test if your challenge is solvable is by trying to solve it yourself.I hope you could gather some ideas for your next crackme or maybe even your first crackme. Microsoft NtQueryInformationProcess Documentation &#8617; Harmony Prefix Patching &#8617; " }, { "title": "Taking a look at AntiDumps", "url": "/posts/Taking-a-look-at-AntiDumps/", "categories": "dotnet, reverse-engineering", "tags": "", "date": "2021-08-24 14:46:24 +0000", "snippet": "After developing a runtime packer in the last post, I tinkered with anti dumping techniques using PE Header manipulation. In this post I will talk about different approaches and take a look at the commonly used dumper ExtremeDumper.*ConfuserEx AntiDump is not included in this article as it would be enough for an entire articleWhat is a memory dump?A memory dump consists of the recorded state of the working memory of a computer program at a specific time. In our case this would be the state of the memory once an assembly is fully loaded.A memory dump is typically used to extract dynamically loaded assemblies or information that is decrypted at runtime. This article will focus on dumping tools that dump an entire .NET assembly at runtime.Why do people use AntiDumpTrying to prevent people from dumping your process memory can have many reasons. The most obvious reason would be runtime decryption for example the method body encryption used by ConfuserEx which will only decrypt the CIL method bodies on runtime. Meaning the easiest way to restore the CIL bodies is by dumping the app with the decrypted method bodies from memory. Another obvious target for dumping are runtime packers that decrypt and invoke their payload on runtime. Instead of reverse engineering often heavily obfuscated code, you can simply dump the payload from memory.Preventing a memory dumpProcess namesIn order to prevent a memory dump we can do a few things. The simplest solution you have probably seen many times, is checking for process names. If a known dumper process is found the app will trigger some action. However, this technique is quite trivial to bypass as one can simply rename their dumper. Not to mention a list of bad process names is an obvious flag for any reverse engineer. Another downside is the need to constantly monitor running processes.Erasing PE Header dataAnother commonly used anti dumping solution I have seen many times is erasing certain fields in the PE Header. Unlike native apps we cannot just erase the entire PE Header since it is used by the .NET CLR after initialization. Lets look into one of the most common classes used for erasing PE Header information.public static void AntiDump() { var process = System.Diagnostics.Process.GetCurrentProcess(); var base_address = process.MainModule.BaseAddress; var dwpeheader = System.Runtime.InteropServices.Marshal.ReadInt32((IntPtr)(base_address.ToInt32() + 0x3C)); var wnumberofsections = System.Runtime.InteropServices.Marshal.ReadInt16((IntPtr)(base_address.ToInt32() + dwpeheader + 0x6)); EraseSection(base_address, 30); ...Code by Mecanik, from hereFirst of all, we get the current process and the BaseAddress of its MainModule. The BaseAddress is the beginning of the current module’s PE Header. We continue by reading the value of e_lfanew, a field located in the DOS Header which contains the offset to the beginning of the File Header. The value is stored in the local variable dwpeheader. Next, we read NumberOfSections from the File Header. To obtain its address the value of dwpeheader and an offset of 0x6 is added to the BaseAddress.Next off, EraseSection is called with the BaseAddress and 30 supplied as parameters. It overwrites the specified amount of bytes at the given address with zero bytes using the functions VirtualProtect and ZeroMemory exported by kernel32.dll.[DllImport(\"kernel32.dll\")]private static extern IntPtr ZeroMemory(IntPtr addr, IntPtr size);[DllImport(\"kernel32.dll\")]private static extern IntPtr VirtualProtect(IntPtr lpAddress, IntPtr dwSize, IntPtr flNewProtect, ref IntPtr lpflOldProtect);private static void EraseSection(IntPtr address, int size) { IntPtr sz = (IntPtr) size; IntPtr dwOld = default(IntPtr); VirtualProtect(address, sz, (IntPtr) 0x40, ref dwOld); ZeroMemory(address, sz); IntPtr temp = default(IntPtr); VirtualProtect(address, sz, dwOld, ref temp);}Let’s take a closer look at EraseSection. Initially VirtualProtect is called to set the protection for the desired memory region to PAGE_EXECUTE_READWRITE(0x40). Which enables read, write, and execution permissions for that region. Next, ZeroMemory is called on the before unprotected region, which will overwrite the specified region size with zero bytes. Finally, the protection of the region is restored to the previous protection by calling VirtualProtect again but with the old protection as the flNewProtect argument.for (int i = 0; i &lt; peheaderdwords.Length; i++) { EraseSection((IntPtr)(base_address.ToInt32() + dwpeheader + peheaderwords[i]), 4);}The code continues with erasing some specific fields in the File Header, Optional Header, and the Section Table using multiple arrays of hardcoded offsets. This is done using multiple loops which iterate trough the arrays containing the offsets. For every offset it calls EraseSection using the following address chain: base_address + dwpeheader + the array value at index i.I will not go over that part in too much detail, however I wrote a simple tool to map the offsets used in the code to their corresponding fields in the PE Header. The tool and a list of all the mapped fields can be found here, code is commented so you can follow the process.0x20 offset to Section_Linenumbers_Number in the Section Table =&gt; location: 0000019A0x8 offset to Unknown in the Section Table =&gt; location: 000001820xC offset to Unknown in the Section Table =&gt; location: 000001860x10 offset to Unknown in the Section Table =&gt; location: 0000018A0x14 offset to Unknown in the Section Table =&gt; location: 0000018E0x18 offset to Unknown in the Section Table =&gt; location: 000001920x1C offset to Unknown in the Section Table =&gt; location: 000001960x24 offset to Unknown in the Section Table =&gt; location: 0000019EIf you check the full list you will notice a few fields mapped to Unknown, these are offsets that point to somewhere inside the Section Table however they seem to be incorrect as they don’t point to a specific field but only at data in between 2 fields. Take a close look at the locations shown in the above segement of the mappers output and compare them to the actual field offsets taken from CFF explorer.You will see that the locations resolved by the mapper dont match with any of the field offsets that CFF Explorer shows. Instead they seem to be off by two, for example the first offset in the sectiontablewords array 0x8 results in the location 00000182 which is plus two off from Virtual Size and minus two off from Virtual Address. This might be intentional but I cannot make any sense of it.int x = 0;int y = 0;while (x &lt;= wnumberofsections) { if (y == 0) { EraseSection((IntPtr)((base_address.ToInt32() + dwpeheader + 0xFA + (0x28 * x)) + 0x20), 2); } EraseSection((IntPtr)((base_address.ToInt32() + dwpeheader + 0xFA + (0x28 * x)) + sectiontabledwords[y]), 4); y++; if (y == sectiontabledwords.Length) { x++; y = 0; }}This part contains the offsets that I assume to be invalid. The loop iterates through all sections and erases certain fields using an array of offsets and one hardcoded offset. However only the hardcoded offset 0x20 seems to be correct, it resolves to Linenumbers Number. The other offsets point to data in between fields as previously mentioned.Some comments on the codeImporting native functions like ZeroMemory and VirtualProtect is a pretty big hint for reverse engineers, that there will likely be some kind of data manipulation or memory manipulation going on. Native imports are also quite easy to spot even when obfuscated, due to the DllImport attribute containing the dll’s name aswell as the EntryPoint which is the name of the function that is imported. This however is the case for basically every AntiDump that relies on PE Header manipulation, since by default the memory region of the PE Header is marked read-only. To change this and enable write permissions it is hard to circumvent calling either VirtualProtect or VirtualProtectEx*. Coming back to this specific implementation, the way VirtualProtect is used here is highly inefficient, as it is called for every offset in the array while all offsets are in a certain range within the PE Header. Since the offsets of the fields that are being erased are known one could simply change the memory protection for the entire range until the biggest offset. Changing the protection once for this range and then restoring it after completing all overwrites would be a lot more efficent. Additionaly I would utilize 0x04 (READ_WRITE) for memory protection as thats sufficent for overwriting/erasing values. Another point I would critique: A lot of the fields being erased are zero by default, so overwriting them seems pointless. The biggest issue in my opinion: All offsets are hardcoded for PE32 which means the code only works on 32bit applications.*You can also use NtProtectVirtualMemory but its undocumented and does not offer any particular benefit over normal VirtualProtect.Modifying the PE HeaderInstead of simply erasing data from the PE Header why not change a few values to break common dumpers. To understand what we need to modify we will take a quick look into how dumpers like ExtremeDumper parse the image in memory.In order to dump the image in memory ExtremeDumper will parse the PE Header. The PE Header contains important information about the structure of the file. This includes the virtual addresses of the sections, the machine type and import address table. The structure of the header is mostly the same everytime it starts with the DOS Header which is 60 bytes in size. The DOS Header does not contain much information apart from the offset to the File Header and the PE signature MZ (also called PE Magic). You can erase the entire DOS Header from memory on runtime and your app will run just fine, since the PE Loader and CLR only require the DOS Header for initialization. The File Header that follows the DOS Header however is a bit more important, it contains information like the number of sections and the size of the Optional Header. These two values are actually the most important ones for further processing. ExtremeDumper, or rather dnlib which is used to parse the PE Header, requires the value of SizeOfOptionalHeader to correctly parse the Optional Header and calculate the correct image size. After some testing it turned out that changing the value of SizeOfOptionalHeader only works for x64 compiled binaries and only with short.MaxValue. I could not find the exact reason for this behavior but it seems like x64 binaries are loaded differently by the CLR compared to x86 binaries.While checking the DOS Header parser of dnlib I noticed that simply changing the PE Signature, or erasing it, is enough to abort parsing by dnlib. Which means we could just replace the DOS Headers PE Signature with something else for example the signature for a ZIP file. It will look like a valid header in memory instead of being a block of zero bytes followed by the File Header.The example uses a 32bit C# console application.This is a dump of the original PE Header notice the PE Signature MZ or as dnlib reads it 0x5A4DThis is a dump of my modified PE Header notice the Signature changed to PK which is actually for ZIP files. Dnlib would in this case read 0x4B50 as the Signature and abort further parsing.While changing values in the PE header is quite successful for many dumpers, some dumpers are actually able to deal with it just fine. One problem with PE Header manipulation is that we only modify the image in memory but not the image on disk. Many dumpers have features that compare the two versions of the image and can thereby fix some overwritten values. In the next section I will go into the different approaches one could take to counter runtime PE Header manipulation.An example implementation of the above described can be found hereCode references:ExtremeDumper NormalDumper.cs |dnlib PEInfo.cs |dnlib ImageDosHeader.csCountering AntiDump protectionsUsing the disk imageAs you might have noticed most of the above mentioned protection schemes rely on PE Header manipulation on runtime, meaning the PE Header on disk is almost always completely fine. A simple way to mitigate erased PE Header info is just comparing the dump to the disk image and fixing unusual or missing data. You can even do that on runtime parsing both disk image and memory image checking them against each other. If we find anomalies, such as an invalid value for SizeOfOptionalHeader, we can compare those invalid values with the original data from the disk image and then replace them if necessary. Another solution is checking redundant fields of the PE Header for example we could check if the machine type adds up with the size of the Optional Header. The Optional Headers size will by default always be the same for x64 and x86. So checking the machine type can give us a hint for the correct size even if it was changed. Many more complex AntiDumps techniques will also erase .NET metadata. In that case using the disk image for comparison is again a great way to fix the issue.Patching the binaryWhat you can also easily do most of the time, is removing the AntiDump method from the binary or if that is not possible, hook it using Harmony for example. How exactly the hook looks like is not that important as there are many different ways to patch the AntiDump. When looking for AntiDump methods in virtualized code or heavily obfuscated code you can almost always rely on the required usage of VirtualProtect or any other memory protection function. This means that by using either a Debugger or a API monitoring tool we can find the code region that calls VirtualProtect and patch it or hook it. However this requires knowledge of assembly code.Bonus: “Hiding” P/Invoke methodsOne big issue with many AntiDumps is that they need to use P/Invoke to import native functions, which is easy to spot for reverse enginners. What can you do to obscure or hide the imports of native functions? Let us have a look at a couple of methods to hide the imported functions.Dynamic invokingFor this we will dynamically resolve a functions address using GetProcAddress. The disadvantage of this method is obviously that we still have to use a P/Invoke method, however we can obfuscate the name of the actual function we want to call.[DllImport(\"kernel32\", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);[UnmanagedFunctionPointer(CallingConvention.StdCall)]private delegate uint PVM(IntPtr ProcessHandle, ref IntPtr BaseAddress, ref uint numberOfBytes, uint newProtect, out uint oldProtect);public static IntPtr GetLoadedModuleAddress(string dllName) { var procModules = Process.GetCurrentProcess().Modules; foreach(ProcessModule mod in procModules) { if (mod.ModuleName != dllName) continue; return mod.BaseAddress; } return IntPtr.Zero;}private static IntPtr GetFunctionPointer(string dllName, string functionName) { var hModule = GetLoadedModuleAddress(dllName); return GetProcAddress(hModule, functionName);}First we import GetProcAddress from kernel32.dll using DllImport. Next we define a delegate with the UnmanagedFunctionPointer attribute since we will cast a native function pointer to this delegate later. The delegate PVM is for NtProtectVirtualMemory from ntdll.dll which is the underlying function of VirtualProtect. The GetLoadedModuleAddress function will get the base address of the specified ProcessModule from the current process. The most important function GetFunctionPointer gets the native function pointer of the specified function from the specified dll. Im using this method instead of GetModuleHandle to avoid further native imports.public static void Protect() { string dllName = Encoding.UTF8.GetString(Convert.FromBase64String(\"bnRkbGwuZGxs\")); // ntdll.dll string functionName = Encoding.UTF8.GetString(Convert.FromBase64String(\"TnRQcm90ZWN0VmlydHVhbE1lbW9yeQ==\")); // NtProtectVirtualMemory var fPointer = GetFunctionPointer(dllName, functionName); PVM pvm = Marshal.GetDelegateForFunctionPointer&lt;PVM&gt;(fPointer); var p = Process.GetCurrentProcess(); var @base = p.MainModule.BaseAddress; uint size = 0x3C; pvm(p.Handle, ref @base, ref size, 0x04, out uint oldProtect); Marshal.Copy(new byte[size], 0, @base, (int) size); pvm(p.Handle, ref @base, ref size, oldProtect, out _);}Let’s look into the actual protection code. First we specifiy the dllName and functionName parameters for GetFunctionPointer. I use simple Base64 Encoding in this example but you can use any kind of string encryption or encoding to obfuscate the names. Next we call GetFunctionPointer with the supplied names to obtain the address of our desired function. In this situation, I resolve the address to NtProtectVirtualMemory in ntdll.dll. We assign the delegate by casting the obtained address to a delegate using Marshal.GetDelegateForFunctionPointer&lt;T&gt;.After assigning the delegate we get the current process and obtain the base address of its main module. Using the base address and a handle to our current process we call the pvm delegate to change the memory protection of the first 60 bytes (size of the DOS Header) of our module to 0x04 (READWRITE). We then copy an array of zero bytes to the location of the DOS Header thereby overwriting it entirely with zero bytes. Last we restore the memory protection of the DOS Header back to the old protection.This might not be the best way of hiding native imports but it is better than simply exposing them without any kind of obfuscation.The used example code can be found hereSyscallsThis will implement direct syscalls completely avoiding exposing the funtion name or its dll name. It will also bypass basic usermode hooks on the functions we are syscalling. Disadvantages of this method are that it relies on native shellcode and we can only call functions that exist as a syscall.In order to do a syscall we need to look at the function we are trying to syscall in my case NtProtectVirtualMemory also known as ZwProtectVirtualMemory.Lets check the function in IDA to see how the syscall is implemented.64bit version of ntdll.dllThe index of the syscall in this case 0x50 (50h) is pushed into eax. The syscall instruction will use the index in eax to resolve the function its supposed to call.Since C# does not support inline assembly, we will need to create shellcode to syscall from our managed app.mov r10, rcxmov eax, 0x50syscallretBasically we just copy the function dissassembly from IDA but remove the test and jnz instruction. This pattern is pretty much the same for every syscall except the index thats pushed into eax. (This shellcode only works for 64bit apps)Lets implement this in C#. We will need to import kernel32.dll VirtualProtect. And just as in the dynamic invoke example we need a delegate for NtProtectVirtualMemory. (You could combine this with the native invoke to hide the VirtualProtect import)private static PVM pvm;private static byte[] Shellcode = { 0x49, 0x89, 0xCA, // mov r10,rcx 0xB8, 0x50, 0x00, 0x00, 0x00, // mov eax, 0x50 0x0F, 0x05, // syscall 0xC3 // ret};static Suscall() { fixed(byte* ptr = &amp;Shellcode[0]) { if (!VirtualProtect(ptr, (uint) 10, 0x40, out _)) throw new Win32Exception(); pvm = Marshal.GetDelegateForFunctionPointer&lt;PVM&gt;((IntPtr) ptr); }}The above assembled shellcode is stored as raw bytes. The Suscall function is a static constructor to initialize the shellcode and cache the delegate. This process is pretty similar to the dynamic invoke example however instead of resolving the function pointer we allocate the shellcode in a fixed buffer and then cast it to our previously defined PVM delegate. The delegate will directly call the syscall just like NtProtectVirtualMemory does. Using this we don’t need to invoke the NT function anymore, thereby also preventing a debugger from just setting a breakpoint on the function.public static void Protect() { var p = Process.GetCurrentProcess(); var @base = p.MainModule.BaseAddress; uint size = 0x3C; pvm(p.Handle, ref @base, ref size, 0x04, out uint oldProtect); Marshal.Copy(new byte[size], 0, (IntPtr)@base, (int) size); pvm(p.Handle, ref @base, ref size, oldProtect, out _);}The protection implementation remains mostly the same as before, but we call the cached syscall delegate to directly execute the underlying functionality of NtProtectVirtualMemory. This implementations looks a lot cleaner since the only thing that statically exposes the called function is the syscall index. To further obfuscate this you could encrypt the array containing the shellcode, so its harder to analyze statically.One issue with allocating shellcode and syscalling is that it might be picked up as malware by an antivirus due to the more and more common usage of syscalls in malware. To avoid shellcode usage you could implement this as a native method which would also eliminate the need to use VirtualProtect.The code for this example can be found hereConlusionI think this write up goes to show that simple PE Header manipulation might not be the best way to prevent people from dumping your app. However more complex approaches that involve .NET metadata manipulation can be quite effective against low skill attackers as they will require a lot more effort and knowledge to fix.I hope the bonus segment on hiding P/Invoke methods gave some good ideas on how to obscure/obfuscate native imports. As I think obscuring native imports could be an improvement for some people. If you have any questions regarding the contents of the write up feel free to contact me on discord: drakonia#1110.Credits Jack Halon - Utilizing syscalls in C#" }, { "title": "Writing a Packer", "url": "/posts/Writing-a-Packer/", "categories": "dotnet, coding", "tags": "", "date": "2021-06-24 14:46:24 +0000", "snippet": "Taking a detailed look at my .net executable packer Origami, specifically about the runtime and how it works. Also giving some general overview about packing executables. Basic knowledge of C# and the PE Format is recommended.What is a packer?A packer (specifically a runtime packer) is a software that unpacks itself or a payload in memory when executed. The original idea was to make files smaller due to storage and bandwith limitations, hence why this practice is also referred to as “executable compression”. But with the present-day broad availability of mass storage and increasing bandwith this is rarely needed. Which leads to the present day were packers are mostly used to make reverse engineering more difficult or in some cases hide malicious code from static scanning.Due to the increasing malicious use of packers I decided to not include any major anti reverse engineering or stealth features. The write up will only focus on the basic concept of compressing an executable and unpacking it on runtime.Writing your own packerWhen I first looked into writing a packer I came accross the native packer UPX, which uses PE sections to store the packed executable data (payload). Since to my knowledge no open source .NET packers exist that tinker with PE sections. I set myself the goal to create the first open source .NET packer using PE sections. Most existing .NET packers rely on embedded resources or pre-initialized arrays for payload storage and I wanted do to something different. (When I recoded Origami, I added another payload storage option besides the PE section. You can choose between debug directory and PE section now) For easier perception I tried to visualize my idea.Processing the data and creating a stubWe begin by parsing our input executable as raw data (bytes). For further processing we will use AsmResolver. Additionally we parse the input executable as a ModuleDefinition which we will later use to obtain some basic info like FileCharacteristics, PEKind etc. these values will be used for the stub creation. Furthermore we need to parse the custom attributes from the input executable and import them into the stub module.The next step is building the stub executable, the stub is the part of the packer that unpacks the actual packed executable in memory. To run the unpacked executable from memory I will use simple Reflection invoking. First we create a new ModuleDefinition and pass the following arguments: payloads module name, payloads CorLib assembly as AssemblyReference. Once we created the module for the stub we will apply the previously mentioned info and custom attributes from our payload module.Code reference can be found hereAfter that we will add the payload data to our stub (actually I inject the loader first but we will skip that for now, since the loader code requires a longer explanation). Before we add the payload data it will be compressed and encrypted with a single xor operation. For compression and decompression I use the .NET inbuilt DeflateStream.If the PE section mode was chosen we add a new PESection containing a DataSegment which holds our payload. The new PESection will be called .origami. The Characteristics need to include atleast the read access flag, I additonally apply the unintialized data flag.If the debug directory mode was chosen we clear the current debug directory and add a new CustomDebugDataSegment containing a DataSegment storing our payload instead of actual debug information. I will not go into detail explaining the code for this process as I think its fairly easy to understand, however the code references are included below if youre interested.Code reference for the PE section packer can be found hereCode reference for the debug directory packer can be found hereNow to the step we skipped, injecting the loader code. The loader is the part that will unpack the payload at runtime.The PE section loaderThis loader code will be used together with the additional PE section mentioned in the previous paragraph. It parses the PE header on runtime to find the additional section, extract the data from it and then use it to invoke the original executable.// Call GetHINSTANCE() to obtain a handle to our modulebyte* basePtr = (byte*) Marshal.GetHINSTANCE(Assembly.GetCallingAssembly().ManifestModulebyte* ptr = basePtr;// Parse PE header using the before obtained module handle// Reading e_lfanew from the DOS headerptr += *(ushort*) (ptr + 0x3C// Reading NumberOfSections the file headerushort NumberOfSections = *(ushort*) (ptr + 0x6ushort optHeaderSize = *(ushort*) (ptr + 0x14ptr += 0x18 + optHeaderSize;Lets look at the Main method which will be injected into the stub and used as its EntryPoint. First we obtain a pointer to the base of our module (basePtr), aka the beginning of the PE header. After we assign ptr the value of basePtr. We then use the ptr variable to parse the relevant information for reading the sections from the PE header.Then we get the value of e_lfanew a field defined in the DOS header which indicates the address of the new executable header. The field is located at offset 0x3C. The value of e_lfanew is by default 0x80 however it doesnt have to be since there are certain cases were additional data exists between DOS header and new executable header.After we added the value of e_lfanew to ptr we will go on to read the field NumberOfSections from the new executable header we obtain that value by adding the offset 0x6 to ptr and casting the pointer to an unsigned short pointer, the cast is required because NumberOfSections is of type WORD which in C# equals a ushort. We then dereference the casted pointer to aquire the value of NumberOfSections from the PE header and assign the value to our local called NumberOfSections.We repeat the above described but this time we add a different offset 0x14 to obtain the value of SizeOfOptionalHeader. This value is needed since the optional headers size changes depending on bitness. The 32bit optional header is slightly smaller than the 64bit optional header, which means following data differs in position depending on the size of the optional header. We assign the aquired value to optHeaderSizeIn the next step we add an offset 0x18 (size of file header) and the value of optHeaderSize to ptr basically we skip the file header and the optional header and jump to the beginning of the section table. Now we need to parse the single sections from the section table.[StructLayout(LayoutKind.Explicit)]private struct IMAGE_SECTION_HEADER{ [FieldOffset(0)] public fixed byte Name[8]; [FieldOffset(12)] public uint VirtualAddress; [FieldOffset(16)] public uint SizeOfRawData; [FieldOffset(36)] private uint Characteristics;}This struct is used to parse the individual section headers from the section table. Each section header contains additional information about the section. However we only need a few fields from that header: Name, location in memory VirtualAddress and the size of the section SizeOfRawData. The last field Characteristics is not used but required to get the correct size of the struct. reference for the stuct defintion can be found here// Read section headersvar ImageSectionHeaders = new IMAGE_SECTION_HEADER[NumberOfSections];for (int headerNo = 0; headerNo &lt; ImageSectionHeaders.Length; headerNo++){ ImageSectionHeaders[headerNo] = *(IMAGE_SECTION_HEADER*) ptr; ptr += sizeof(IMAGE_SECTION_HEADER);}The loop parses all section headers and puts them in an array ImageSectionHeader. To read the section header we use the previously mentioned struct as a pointer. C# accepts structs as a pointer if it only contains unmanaged types, and that is the reason for the fixed byte in the struct since a C# byte array is not an unmanaged type.// Get name of EntryPointstring name = Assembly.GetCallingAssembly().EntryPoint.Nam// Iterate through all PE sectionsforeach (var section in ImageSectionHeaders){ // Check if PE section name matches first 8 bytes of stub EntryPoint bool flag = true; for (int h = 0; h &lt; 8; h++) if (name[h] != *(section.Name + h)) flag = fals if (flag) { // Initialize buffer using size of raw data // Copy data from PE section into buffer and simultaneously (un)xor it byte[] buffer = new byte[section.SizeOfRawData]; basePtr += section.VirtualAddress; fixed (byte* p = &amp;buffer[0]) { for (int i = 0; i &lt; buffer.Length; i++) { *(p + i) = (byte) (*(basePtr + i) ^ name[i % name.Length]); } } ...After parsing all the section headers we aqurire the calling assemblies managed EntryPoint name which will be .origami. The name is then stored as string name which will be later used for xor decryption and matching the correct section. We continue by finding the section that contains our payload. We iterate through our array of section headers and check if any sections name matches name. If we find a matching section we use it to get the payload. First we initialize a byte array buffer with the SizeOfRawData of our matched PE section. Then we add the VirtualAddress of the section to basePtr, its important that we use basePtr since the VirtualAddress is relative to the base of the module.Next step is copying the data from the PE section into our buffer, using a simple byte pointer operation. Simultaneously we apply the same xor operation as during the encryption to decrypt the payload byte by byte.// Decompress data from the bufferusing var origin = new MemoryStream(buffer);using var destination = new MemoryStream();using var deflateStream = new DeflateStream(origin, CompressionMode.Decompress);deflateStream.CopyTo(destination);Once we are done copying and decrypting the data we pass the buffer into a MemoryStream (origin). The origin stream is then passed to a DeflateStream with the parameter CompressionMode.Decompress to decompress the payload. The decompressed data is then copied from the DeflateStream to a new MemoryStream here called destination.Now in order to run the payload we need to invoke it. We pass the buffer of the destination stream, which is the streams content as a byte array, into an Assembly.Load() call. We can the locate the loaded assemblies EntryPoint and invoke it. Additionally if any commandline arguments were provided we pass them to the payload executable. Code reference can be found hereThe debug directory loaderThis loader is used together with a lesser known part of the PE structure, the debug directory. It is a special data directory used to store debug information for an executable. However since the data stored in this directory can be anything we can abuse it for our packers payload.The code is in theory very similar to the previously described PE section loader. What changed is the part of locating the compressed data.// Call GetHINSTANCE() to obtain a handle to our modulebyte* basePtr = (byte*) Marshal.GetHINSTANCE(Assembly.GetCallingAssembly().ManifestModule// Parse PE header using the before obtained module handle// Reading e_lfanew from the DOS headerbyte* ptr = basePtr + *(uint*) (basePtr + 0x3C// Check the optional header magic to determine 32-bit vs 64-bitshort optMagic = *(short*) (ptr + 0x18// 0x20b = IMAGE_NT_OPTIONAL_HDR64_MAGIC uint DebugVirtualAddress = optMagic != 0x20b ? *(uint*) (ptr + 0xA8) : *(uint*) (ptr + 0xB8);One again we begin by obtaining a pointer to the base of our module (basePtr), aka the beginning of the PE header. We then get the value of e_lfanew as described previously and assign its value plus basePtr to ptr. Next thing we aquire is the value of Magic, the first field of the optional header and assign it to optMagic. Depending on bitness the value of Magic is either 0x10b for 32bit or 0x20b for 64bit. Since the next value that we need is located in the optional header we need to determine which header is present (32bit header is smaller than 64bit header, which results in different offsets). Next we check if optMagic is not 0x20b, if that is the case we assign the value located at ptr plus offset 0xA8 to DebugVirtualAddress. The pointer chain points to the location of Debug Directory RVA in the 32bit optional header. If optMagic is 0x20b a different offset 0xB8 will be added to ptr which results in the value of Debug Directory RVA in the 64bit optional header getting assigned to DebugVirtualAddress.basePtr += DebugVirtualAddress;uint SizeOfData = *(uint*) (basePtr + 0x10);uint AddressOfRawData = *(uint*) (basePtr + 0x14);basePtr -= DebugVirtualAddress;After finding the relative virtual address (RVA) of the debug directory (stored in DebugVirtualAddress) we add it to basePtr. After we parse the first entry of the debug directory which is our payload, since in the stub generation we cleared the debug directory and added only our entry containing the payload. We only need 2 fields from the entry SizeOfData and AddressOfRawData to obtain them we apply an offset of 0x10 to basePtr since we added DebugVirtualAddress to basePtr it now points to the beginning of the debug directory. And the value at offset 0x10 in the debug directory entry is SizeOfData. Next we do the same for AddressOfRawData using the offset 0x14. Once we have aquired these two values we subtract DebugVirtualAddress from basePtr to ensure its pointing to the beginning of the PE header again. That step is required since AddressOfRawData which is the location of our payload data, is relative to the base of the module.byte[] buffer = new byte[SizeOfData];basePtr += AddressOfRawData;fixed (byte* rawData = &amp;buffer[0]){ for (int i = 0; i &lt; buffer.Length; i++) { *(rawData + i) = (byte) (*(basePtr + i) ^ name[i % name.Length]); }}This snippet is almost identical to the PE section loader except the location we copy the data from is aquired by adding AddressOfRawData to basePtr and we use SizeOfData to initialize our buffer byte array. The copying, decryption, decompression and invoking is done exactly the same way as in the PE section loader.Finnishing the packed fileAfter all the above is done all thats left to do is writing our stub module to disk. Once the file is written to disk youve got your own packed version of the input file." }, { "title": "Writing a simple Unpacker", "url": "/posts/Writing-a-simple-unpacker/", "categories": "dotnet, reverse-engineering", "tags": "", "date": "2020-10-31 14:46:24 +0000", "snippet": "Unpacking simple protections of common confuserex mods and other open source obfuscators. This write up was made for beginners, so if you are an experienced reverse engineer its probably not for you. Basic knowledge of C# and CIL is assumed. Keep in mind that the concepts and code shown are my approach, it can be done in different ways for example using emulation.Contents: Getting started Deconstructing protections Credits1. Getting startedI got the idea of writing a custom unpacker to solve mutations/protections that could not be solved by de4dot after coming across more &amp; more ConfuserEx modifications using \"custom\" protections that could not be unpacked by de4dot, an example would be using sizeof() for integer mutations. Those are quickly removed but doing it manually is quite time wasting. So I decided to write a tool for it.I chose AsmResolver as an assembly editing library. I started out by taking a look at the protections that I wanted to fix. To remove a protection we will first need to understand how the protection works. In my case the source code of most of the protections themselves was available in quite a few public ConfuserEx forks. But even if the source is not available we can determine how a protection works by decompiling a sample.2.0 Deconstructing: Sizeof MutationsA very common example are sizeof() mutations found in numerous public ConfuserEx forks. The most basic version looks somewhat like this:Lets say our original code looks like this:int a = 256Now we run it through an obfuscator using sizeof() mutations, the result could look like this:int a = 260 - sizeof(int);The simple variable has been converted into an expression, sizeof(int) will return a value of 4 (sizeof msdn). So its basically just int a = 260 - 4.&lt;br&gt;While de4dot will simplify int a = 260 - 4 to int a = 256 it will not simplify the expression containing sizeof(int) so to fix this we will need to get rid of the sizeof.To understand how we can remove the sizeof from our expression we will first need to take a look at the CIL Code of our expression.ldc.i4 260sizeof System.Integersub ldc.i4 OpCode with the operand value of 260 initializes an integer with said value. sizeof OpCode with the operand System.Integer represents sizeof(int) which will result in a integer value of 4. sub OpCode stands for subract (-).To get rid of the sizeof we will resolve its resulting integer value and replace the sizeof OpCode with an integer (ldc.i4 OpCode). I will explain the concept below: Get all Types and their methods Foreach method that has a CILBody check if the instructions contain sizeof OpCode(s) For every found sizeof OpCode call GetImpliedMemoryLayout(is32Bit true/false)¹ (feature of AsmResolver) If you dont use AsmResolver you can run a dynamic method that calls sizeof(T). T being the the operand type of the sizeof OpCode². Replace the sizeof OpCode with an ldc.i4 OpCode and set its operand to the value thats returned by GetImpliedMemoryLayout. Call OptimizeMacros() to optimize CIL like ldc.i4 1 to ldc.i4.1My full code can be found here 1. This assumes that you have before determined if the code is 32bit or not. If the code is 32bit call the method with the parameter true else use false. 2. This requires reflection while AsmResolvers method is completely static. 2.1 Deconstructing: Locals to FieldsAnother example found in numerous forks of ConfuserEx is the locals to fields protection it basically does what the name says it converts locals to field. Since de4dot will not simplify expressions that include field values we want to restore the fields back to locals.The examples I have found during my research mostly work somewhat like this: OpCodes like stloc, ldloc and ldloca are replaced with their field equivalents stsfld, ldsfld, ldsflda The replacement fields are created in the global type¹, &lt;Module&gt; by default. These fields will have the attributes: public and static. (Optional) Sometimes one field is used to replace multiple locals of the same type, for example all locals of the type int are replaced with the same field. 1. The fields could also be created in any other public type, but all forks I looked at used the global type. Lets say the original code looks like thisstring text = SomeMethodThatReturnsAString();if (text.Length &gt; 0){ Console.WriteLine(text);}After running it through an obfuscator using locals 2 fields we will receive something like this. Instead of to a local the string returned by SomeMethodThatReturnsAString() is now assigned to a field thats intialized in the global type.&lt;Module&gt;.Field0 = SomeMethodThatReturnsAString();if (&lt;Module&gt;.Field0.Length &gt; 0){ Console.WriteLine(&lt;Module&gt;.Field0);}Looking at the IL of the above shown code shows how minor these changes actually are. First we will look at the CIL Code of our original code. (code is simplified)call string C::SomeMethodThatReturnsAString()stloc.0ldloc.0 callvirt instance string [mscorlib]System.String::get_Length()ldc.i4.0...ldloc.0call void [System.Console]System.Console::WriteLine(string)...If we compare this to the obfuscated CIL Code it looks very similar. The OpCodes that set and load our locals value have been replaced with their field equivalents.call string C::SomeMethodThatReturnsAString()stsfld string &lt;Module&gt;::Field0ldsfld string &lt;Module&gt;::Field0callvirt instance int32 [System.Private.CoreLib]System.String::get_Length()ldc.i4.0...ldsfld string &lt;Module&gt;::Field0call void [System.Console]System.Console::WriteLine(string)...So to convert the fields back to locals we will do the following: Search for fields that match the criteria (!private and static, has no default value, only used in one method) in the global type Check all method bodies for OpCodes were the operandtype is InlineField and the operand is a FieldDefinition Check if the matched FieldDefinition is one of the fields that we gathered from the global type: if true: Add new local with the same type as the fields type, change all calls to the matched field with the newly created local. Store the replaced field and new local in a dictionary. Check if there is already a local for the matched field. If there is already an entry for the field use the entry from the dictionary. if false: skip (Optional) Call OptimizeMacros() (Optional) Remove all fields that were replaced. In my case the ones from the before used dictionary.My full code can be found here2.2 Deconstructing: Math MutationsAnother protection that can be seen quite often in modified ConfuserEx versions, or standalone obfuscators. Are math mutations, using System.Math methods like Floor() and Ceiling() to generate expressions or replace simple integers.We will start with the original code again:int a = 256;Now the obfuscated one. As you can see its quite hard to guess the original number of our integer now.int a = (int)Math.Floor(102402.0) - 102146;What the obfuscator has done is create an expression that will result in our original integer. I will not go in to the details of how that is achieved as it is not that important for unpacking this protection. Lets look at the CIL Code of the obfuscated snippet.ldc.r8 102402call float64 [System.Private.CoreLib]System.Math::Floor(float64)conv.i4ldc.i4 102146sub ldc.r8 OpCode represents the parameter supplied to Math.Floor() its operand is the value call OpCode will call Math.Floor() with the above supplied value conv.i4 OpCode casts the result of Math.Floor() to integer. Which is required since the second value of the expression is an integer (ldc.i4) ldc.i4 OpCode pushes an integer with the value of its operand onto the stack sub OpCode stands for subtract (-)In order to make this fixable by de4dot we will need to get rid of the Math.Floor() so what we will do to archieve this is the following: Check method bodies for instructions which operand is a MemberRef with the DeclaringTypes FullName equal to System.Math Use Reflection to resolve the method using the resolved MemberRefs MetadataToken (make sure to resolve it from the original System.Math class)¹ Check the methods parameter count Get the parameters required from the instructions operands, and Nop the instructions. Implement a check that only includes constant types if the obtained params are not a constant type continue (skip further processing) Invoke the method with the paramters obtained before Replace the call instruction with the OpCode related to the return type of our math function in this case ldc.r8 and set its operand to the result returned by the invoked method1. This will fail if the target app uses a different framework, to do it properly we would have to resolve the target framework and use its math class. Fix will be added laterMy full code can be found here2.3 Deconstructing: Calls to CalliCalls to Calli can be found in most ConfuserEx forks however the implementation thats commonly used is not very effective.For this example we will skip looking at the C# Code and checkout the CIL Code instead. Lets start with the original codecall void [System.Windows.Forms]System.Windows.Froms.Application::EnableVisualStyles()If we look at the CIL Code produced by the calls to calli protection, we can see that the ldftn OpCodes operand is the same as the call OpCodes operand in the unobfuscated code, with a little thinking it is pretty obvious how simple the fix will be.ldftn void [System.Windows.Forms]System.Windows.Froms.Application::EnableVisualStyles()calli void()To get rid of the calli protection we will do the following: Search method bodies for calli OpCodes that are lead by ldftn OpCodes Remove the calli OpCode and Change the ldftn OpCode to callMy full code can be found here3. Credits AnonymooseRE For helping out with Unscrambler and answering a lot of my questions Washi For AsmResolver and answering my questions" }, { "title": "Homoglyph Obfuscation", "url": "/posts/Homoglyph-Obfuscation/", "categories": "dotnet, coding", "tags": "", "date": "2020-06-02 14:46:24 +0000", "snippet": "A while ago I watched a very interesting DEF CON talk called “Repsych: Psychological Warfare in Reverse Engineering” by Chris Domas. In his talk Chris talked about how one could fool and or annoy reverse engineers with some little tricks. This got me thinking what can I do in .net to annoy and or fool reverse engineers. After reading about homoglyphs I had a fun little idea.What are homoglyphs?Homoglyphs are characters that look similar or equal to the default alphabetical characters, however they are actually from different alphabets. For our obfuscation concept, we will abuse the fact that that these characters look almost exactly like normal letters.How can we use homoglyphs?So since the homoglyph characters look just like latin characters, we can use them to have to identical looking names that are actually different. For example we could replace the character M in the name &lt;Module&gt; with an M from a different alphabet.Example://normal latin characters&lt;Module&gt; =&gt; &lt;Module&gt; //replaced character M &lt;Мodule&gt; =&gt; xn--&lt;odule&gt;-tigYou can check if a word contains a homoglyph character using PunnycoderThis is the example from above with a few variations of homoglyphs, as you cann see all of the names look exactly the same in dnSpy. But only the first &lt;Module&gt; is the real global type. An experienced reverse engineer will probably know that the first one always is the real one. However its still a funny little annoyance :) If you want to, you can do this to any name, for example Main(). Keep in mind this is rather a little annoyance than an actual protection.How to do it yourself Getting Homoglyphs:Finding the homoglyph characters yourself is annoying and takes time…Thankfully irongeek made a perfectly working “Homoglyph Attack Generator”, check it out yourself! Renaming: For this part you will need to either write your own renamer using homoglyphs or modify an existing one like ConfuserEx (If I find some time ill release my version) Done :)I hope you enjoyed this little write up, and maybe even learned something or got inspired ^^ ~drakoniaCredits/Sources DEF CON Talk by Chris Domas Punyocder (Tool to convert homoglyphs to encoded ascii) Irongeeks Homoglyph Attack Generator Concept of Punycode" } ]
