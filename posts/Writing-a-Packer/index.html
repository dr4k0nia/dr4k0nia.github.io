<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Writing a Packer" /><meta property="og:locale" content="en" /><meta name="description" content="Taking a detailed look at my .net executable packer Origami, specifically about the runtime and how it works. Also giving some general overview about packing executables. Basic knowledge of C# and the PE Format is recommended." /><meta property="og:description" content="Taking a detailed look at my .net executable packer Origami, specifically about the runtime and how it works. Also giving some general overview about packing executables. Basic knowledge of C# and the PE Format is recommended." /><link rel="canonical" href="https://dr4k0nia.github.io/posts/Writing-a-Packer/" /><meta property="og:url" content="https://dr4k0nia.github.io/posts/Writing-a-Packer/" /><meta property="og:site_name" content="dr4k0nia" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-24T14:46:24+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Writing a Packer" /><meta name="twitter:site" content="@dr4k0nia" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-24T14:46:24+00:00","datePublished":"2021-06-24T14:46:24+00:00","description":"Taking a detailed look at my .net executable packer Origami, specifically about the runtime and how it works. Also giving some general overview about packing executables. Basic knowledge of C# and the PE Format is recommended.","headline":"Writing a Packer","mainEntityOfPage":{"@type":"WebPage","@id":"https://dr4k0nia.github.io/posts/Writing-a-Packer/"},"url":"https://dr4k0nia.github.io/posts/Writing-a-Packer/"}</script><title>Writing a Packer | dr4k0nia</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="dr4k0nia"><meta name="application-name" content="dr4k0nia"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/51999910?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">dr4k0nia</a></div><div class="site-subtitle font-italic">Developer & Reverse-Engineer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust" title="Toggle theme"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dr4k0nia" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dr4k0nia" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dr4k0nia','pm.me'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Writing a Packer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Writing a Packer</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1624545984" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 24, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/dr4k0nia">dr4k0nia</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2412 words"> <em>13 min</em> read</span></div></div></div><div class="post-content"><p>Taking a detailed look at my .net executable packer Origami, specifically about the runtime and how it works. Also giving some general overview about packing executables. Basic knowledge of C# and the PE Format is recommended.</p><h2 id="what-is-a-packer"><span class="mr-2">What is a packer?</span><a href="#what-is-a-packer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A packer (specifically a runtime packer) is a software that unpacks itself or a payload in memory when executed. The original idea was to make files smaller due to storage and bandwith limitations, hence why this practice is also referred to as “executable compression”. But with the present-day broad availability of mass storage and increasing bandwith this is rarely needed. Which leads to the present day were packers are mostly used to make reverse engineering more difficult or in some cases hide malicious code from static scanning.</p><p><em>Due to the increasing malicious use of packers I decided to not include any major anti reverse engineering or stealth features. The write up will only focus on the basic concept of compressing an executable and unpacking it on runtime.</em></p><h2 id="writing-your-own-packer"><span class="mr-2">Writing your own packer</span><a href="#writing-your-own-packer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When I first looked into writing a packer I came accross the native packer UPX, which uses PE sections to store the packed executable data (payload). Since to my knowledge no open source .NET packers exist that tinker with PE sections. I set myself the goal to create the first open source .NET packer using PE sections. Most existing .NET packers rely on embedded resources or pre-initialized arrays for payload storage and I wanted do to something different. <em>(When I recoded Origami, I added another payload storage option besides the PE section. You can choose between debug directory and PE section now)</em></p><p><img data-src="/images/sheme_blue.png" alt="shematic" data-proofer-ignore></p><blockquote><p>For easier perception I tried to visualize my idea.</p></blockquote><h2 id="processing-the-data-and-creating-a-stub"><span class="mr-2">Processing the data and creating a stub</span><a href="#processing-the-data-and-creating-a-stub" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We begin by parsing our input executable as raw data (bytes). For further processing we will use AsmResolver. Additionally we parse the input executable as a <code class="language-plaintext highlighter-rouge">ModuleDefinition</code> which we will later use to obtain some basic info like <code class="language-plaintext highlighter-rouge">FileCharacteristics</code>, <code class="language-plaintext highlighter-rouge">PEKind</code> etc. these values will be used for the stub creation. Furthermore we need to parse the custom attributes from the input executable and import them into the stub module.</p><p>The next step is building the stub executable, the stub is the part of the packer that unpacks the actual packed executable in memory. To run the unpacked executable from memory I will use simple Reflection invoking. First we create a new <code class="language-plaintext highlighter-rouge">ModuleDefinition</code> and pass the following arguments: payloads module name, payloads CorLib assembly as <code class="language-plaintext highlighter-rouge">AssemblyReference</code>. Once we created the module for the stub we will apply the previously mentioned info and custom attributes from our payload module. <em>Code reference can be found <a href="https://github.com/dr4k0nia/Origami/blob/3131d4eb47856774618ee57a7342472d6ca2efa4/src/Packers/IPacker.cs#L33">here</a></em></p><p>After that we will add the payload data to our stub (actually I inject the loader first but we will skip that for now, since the loader code requires a longer explanation). Before we add the payload data it will be compressed and encrypted with a single xor operation. For compression and decompression I use the .NET inbuilt <code class="language-plaintext highlighter-rouge">DeflateStream</code>. <br /> If the PE section mode was chosen we add a new <code class="language-plaintext highlighter-rouge">PESection</code> containing a <code class="language-plaintext highlighter-rouge">DataSegment</code> which holds our payload. The new <code class="language-plaintext highlighter-rouge">PESection</code> will be called <code class="language-plaintext highlighter-rouge">.origami</code>. The Characteristics need to include atleast the read access flag, I additonally apply the unintialized data flag. <br /> If the debug directory mode was chosen we clear the current debug directory and add a new <code class="language-plaintext highlighter-rouge">CustomDebugDataSegment</code> containing a <code class="language-plaintext highlighter-rouge">DataSegment</code> storing our payload instead of actual debug information. I will not go into detail explaining the code for this process as I think its fairly easy to understand, however the code references are included below if youre interested.</p><p><em>Code reference for the PE section packer can be found <a href="https://github.com/dr4k0nia/Origami/blob/3131d4eb47856774618ee57a7342472d6ca2efa4/src/Packers/SectionPacker.cs">here</a></em><br /> <em>Code reference for the debug directory packer can be found <a href="https://github.com/dr4k0nia/Origami/blob/3131d4eb47856774618ee57a7342472d6ca2efa4/src/Packers/DebugDirPacker.cs">here</a></em></p><p>Now to the step we skipped, injecting the loader code. The loader is the part that will unpack the payload at runtime.</p><h3 id="the-pe-section-loader"><span class="mr-2">The PE section loader</span><a href="#the-pe-section-loader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This loader code will be used together with the additional PE section mentioned in the previous paragraph. It parses the PE header on runtime to find the additional section, extract the data from it and then use it to invoke the original executable.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// Call GetHINSTANCE() to obtain a handle to our module</span>
<span class="kt">byte</span><span class="p">*</span> <span class="n">basePtr</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">GetHINSTANCE</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="nf">GetCallingAssembly</span><span class="p">().</span><span class="n">ManifestModule</span>
<span class="kt">byte</span><span class="p">*</span> <span class="n">ptr</span> <span class="p">=</span> <span class="n">basePtr</span><span class="p">;</span>
<span class="c1">// Parse PE header using the before obtained module handle</span>
<span class="c1">// Reading e_lfanew from the DOS header</span>
<span class="n">ptr</span> <span class="p">+=</span> <span class="p">*(</span><span class="kt">ushort</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0x3C</span>
<span class="c1">// Reading NumberOfSections the file header</span>
<span class="kt">ushort</span> <span class="n">NumberOfSections</span> <span class="p">=</span> <span class="p">*(</span><span class="kt">ushort</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0x6</span>
<span class="kt">ushort</span> <span class="n">optHeaderSize</span> <span class="p">=</span> <span class="p">*(</span><span class="kt">ushort</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0x14</span>
<span class="n">ptr</span> <span class="p">+=</span> <span class="m">0x18</span> <span class="p">+</span> <span class="n">optHeaderSize</span><span class="p">;</span>
</pre></table></code></div></div><p>Lets look at the <code class="language-plaintext highlighter-rouge">Main</code> method which will be injected into the stub and used as its EntryPoint. First we obtain a pointer to the base of our module (<code class="language-plaintext highlighter-rouge">basePtr</code>), aka the beginning of the PE header. After we assign <code class="language-plaintext highlighter-rouge">ptr</code> the value of <code class="language-plaintext highlighter-rouge">basePtr</code>. We then use the <code class="language-plaintext highlighter-rouge">ptr</code> variable to parse the relevant information for reading the sections from the PE header. <br /> Then we get the value of <code class="language-plaintext highlighter-rouge">e_lfanew</code> a field defined in the DOS header which indicates the address of the new executable header. The field is located at offset <code class="language-plaintext highlighter-rouge">0x3C</code>. The value of <code class="language-plaintext highlighter-rouge">e_lfanew</code> is by default <code class="language-plaintext highlighter-rouge">0x80</code> however it doesnt have to be since there are certain cases were additional data exists between DOS header and new executable header. <br /> After we added the value of <code class="language-plaintext highlighter-rouge">e_lfanew</code> to <code class="language-plaintext highlighter-rouge">ptr</code> we will go on to read the field <code class="language-plaintext highlighter-rouge">NumberOfSections</code> from the new executable header we obtain that value by adding the offset <code class="language-plaintext highlighter-rouge">0x6</code> to <code class="language-plaintext highlighter-rouge">ptr</code> and casting the pointer to an unsigned short pointer, the cast is required because <code class="language-plaintext highlighter-rouge">NumberOfSections</code> is of type <code class="language-plaintext highlighter-rouge">WORD</code> which in C# equals a <code class="language-plaintext highlighter-rouge">ushort</code>. We then dereference the casted pointer to aquire the value of <code class="language-plaintext highlighter-rouge">NumberOfSections</code> from the PE header and assign the value to our local called <code class="language-plaintext highlighter-rouge">NumberOfSections</code>. <br /> We repeat the above described but this time we add a different offset <code class="language-plaintext highlighter-rouge">0x14</code> to obtain the value of <code class="language-plaintext highlighter-rouge">SizeOfOptionalHeader</code>. This value is needed since the optional headers size changes depending on bitness. The 32bit optional header is slightly smaller than the 64bit optional header, which means following data differs in position depending on the size of the optional header. We assign the aquired value to <code class="language-plaintext highlighter-rouge">optHeaderSize</code> <br /></p><p><img data-src="/images/headerjump2.png" alt="header" data-proofer-ignore></p><p>In the next step we add an offset <code class="language-plaintext highlighter-rouge">0x18</code> (size of file header) and the value of <code class="language-plaintext highlighter-rouge">optHeaderSize</code> to <code class="language-plaintext highlighter-rouge">ptr</code> basically we skip the file header and the optional header and jump to the beginning of the section table. Now we need to parse the single sections from the section table.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">StructLayout</span><span class="p">(</span><span class="n">LayoutKind</span><span class="p">.</span><span class="n">Explicit</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">struct</span> <span class="nc">IMAGE_SECTION_HEADER</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span> <span class="k">public</span> <span class="k">fixed</span> <span class="kt">byte</span> <span class="n">Name</span><span class="p">[</span><span class="m">8</span><span class="p">];</span>
    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">12</span><span class="p">)]</span> <span class="k">public</span> <span class="kt">uint</span> <span class="n">VirtualAddress</span><span class="p">;</span>
    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">16</span><span class="p">)]</span> <span class="k">public</span> <span class="kt">uint</span> <span class="n">SizeOfRawData</span><span class="p">;</span>
    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">36</span><span class="p">)]</span> <span class="k">private</span> <span class="kt">uint</span> <span class="n">Characteristics</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This struct is used to parse the individual section headers from the section table. Each section header contains additional information about the section. However we only need a few fields from that header: Name, location in memory <code class="language-plaintext highlighter-rouge">VirtualAddress</code> and the size of the section <code class="language-plaintext highlighter-rouge">SizeOfRawData</code>. The last field <code class="language-plaintext highlighter-rouge">Characteristics</code> is not used but required to get the correct size of the struct. <em>reference for the stuct defintion can be found <a href="http://www.pinvoke.NET/default.aspx/Structures/IMAGE_SECTION_HEADER.html">here</a></em></p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Read section headers</span>
<span class="kt">var</span> <span class="n">ImageSectionHeaders</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IMAGE_SECTION_HEADER</span><span class="p">[</span><span class="n">NumberOfSections</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">headerNo</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">headerNo</span> <span class="p">&lt;</span> <span class="n">ImageSectionHeaders</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
    <span class="n">headerNo</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">ImageSectionHeaders</span><span class="p">[</span><span class="n">headerNo</span><span class="p">]</span> <span class="p">=</span> <span class="p">*(</span><span class="n">IMAGE_SECTION_HEADER</span><span class="p">*)</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="p">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_SECTION_HEADER</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The loop parses all section headers and puts them in an array <code class="language-plaintext highlighter-rouge">ImageSectionHeader</code>. To read the section header we use the previously mentioned struct as a pointer. C# accepts structs as a pointer if it only contains unmanaged types, and that is the reason for the fixed byte in the struct since a C# byte array is not an unmanaged type.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Get name of EntryPoint</span>
<span class="kt">string</span> <span class="n">name</span> <span class="p">=</span> <span class="n">Assembly</span><span class="p">.</span><span class="nf">GetCallingAssembly</span><span class="p">().</span><span class="n">EntryPoint</span><span class="p">.</span><span class="n">Nam</span>
<span class="c1">// Iterate through all PE sections</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">section</span> <span class="k">in</span> <span class="n">ImageSectionHeaders</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check if PE section name matches first 8 bytes of stub EntryPoint</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">h</span> <span class="p">&lt;</span> <span class="m">8</span><span class="p">;</span> <span class="n">h</span><span class="p">++)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="p">!=</span> <span class="p">*(</span><span class="n">section</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="n">h</span><span class="p">))</span>
            <span class="n">flag</span> <span class="p">=</span> <span class="n">fals</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Initialize buffer using size of raw data</span>
        <span class="c1">// Copy data from PE section into buffer and simultaneously (un)xor it</span>
        <span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">section</span><span class="p">.</span><span class="n">SizeOfRawData</span><span class="p">];</span>
        <span class="n">basePtr</span> <span class="p">+=</span> <span class="n">section</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">;</span>
        <span class="k">fixed</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="p">*(</span><span class="n">p</span> <span class="p">+</span> <span class="n">i</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(*(</span><span class="n">basePtr</span> <span class="p">+</span> <span class="n">i</span><span class="p">)</span> <span class="p">^</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span> <span class="p">%</span> <span class="n">name</span><span class="p">.</span><span class="n">Length</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">...</span>
</pre></table></code></div></div><p>After parsing all the section headers we aqurire the calling assemblies managed <code class="language-plaintext highlighter-rouge">EntryPoint</code> name which will be <code class="language-plaintext highlighter-rouge">.origami</code>. The name is then stored as string <code class="language-plaintext highlighter-rouge">name</code> which will be later used for xor decryption and matching the correct section. We continue by finding the section that contains our payload. We iterate through our array of section headers and check if any sections name matches <code class="language-plaintext highlighter-rouge">name</code>. If we find a matching section we use it to get the payload. First we initialize a byte array <code class="language-plaintext highlighter-rouge">buffer</code> with the <code class="language-plaintext highlighter-rouge">SizeOfRawData</code> of our matched PE section. Then we add the <code class="language-plaintext highlighter-rouge">VirtualAddress</code> of the section to <code class="language-plaintext highlighter-rouge">basePtr</code>, its important that we use <code class="language-plaintext highlighter-rouge">basePtr</code> since the <code class="language-plaintext highlighter-rouge">VirtualAddress</code> is relative to the base of the module. Next step is copying the data from the PE section into our buffer, using a simple byte pointer operation. Simultaneously we apply the same xor operation as during the encryption to decrypt the payload byte by byte.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Decompress data from the buffer</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">origin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MemoryStream</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">destination</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MemoryStream</span><span class="p">();</span>
<span class="k">using</span> <span class="nn">var</span> <span class="n">deflateStream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DeflateStream</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">CompressionMode</span><span class="p">.</span><span class="n">Decompress</span><span class="p">);</span>
<span class="n">deflateStream</span><span class="p">.</span><span class="nf">CopyTo</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
</pre></table></code></div></div><p>Once we are done copying and decrypting the data we pass the buffer into a <code class="language-plaintext highlighter-rouge">MemoryStream</code> (<code class="language-plaintext highlighter-rouge">origin</code>). The <code class="language-plaintext highlighter-rouge">origin</code> stream is then passed to a <code class="language-plaintext highlighter-rouge">DeflateStream</code> with the parameter <code class="language-plaintext highlighter-rouge">CompressionMode.Decompress</code> to decompress the payload. The decompressed data is then copied from the <code class="language-plaintext highlighter-rouge">DeflateStream</code> to a new <code class="language-plaintext highlighter-rouge">MemoryStream</code> here called <code class="language-plaintext highlighter-rouge">destination</code>.</p><p>Now in order to run the payload we need to invoke it. We pass the buffer of the <code class="language-plaintext highlighter-rouge">destination</code> stream, which is the streams content as a byte array, into an <code class="language-plaintext highlighter-rouge">Assembly.Load()</code> call. We can the locate the loaded assemblies EntryPoint and invoke it. Additionally if any commandline arguments were provided we pass them to the payload executable. <em>Code reference can be found <a href="https://github.com/dr4k0nia/Origami/blob/3131d4eb47856774618ee57a7342472d6ca2efa4/src/Runtime/PeSectionLoader.cs#L91">here</a></em></p><h3 id="the-debug-directory-loader"><span class="mr-2">The debug directory loader</span><a href="#the-debug-directory-loader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This loader is used together with a lesser known part of the PE structure, the debug directory. It is a special data directory used to store debug information for an executable. However since the data stored in this directory can be anything we can abuse it for our packers payload. The code is in theory very similar to the previously described PE section loader. What changed is the part of locating the compressed data.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// Call GetHINSTANCE() to obtain a handle to our module</span>
<span class="kt">byte</span><span class="p">*</span> <span class="n">basePtr</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">GetHINSTANCE</span><span class="p">(</span><span class="n">Assembly</span><span class="p">.</span><span class="nf">GetCallingAssembly</span><span class="p">().</span><span class="n">ManifestModule</span>
<span class="c1">// Parse PE header using the before obtained module handle</span>
<span class="c1">// Reading e_lfanew from the DOS header</span>
<span class="kt">byte</span><span class="p">*</span> <span class="n">ptr</span> <span class="p">=</span> <span class="n">basePtr</span> <span class="p">+</span> <span class="p">*(</span><span class="kt">uint</span><span class="p">*)</span> <span class="p">(</span><span class="n">basePtr</span> <span class="p">+</span> <span class="m">0x3C</span>
<span class="c1">// Check the optional header magic to determine 32-bit vs 64-bit</span>
<span class="kt">short</span> <span class="n">optMagic</span> <span class="p">=</span> <span class="p">*(</span><span class="kt">short</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0x18</span>
<span class="c1">// 0x20b = IMAGE_NT_OPTIONAL_HDR64_MAGIC </span>
<span class="kt">uint</span> <span class="n">DebugVirtualAddress</span> <span class="p">=</span> <span class="n">optMagic</span> <span class="p">!=</span> <span class="m">0x20b</span>
    <span class="p">?</span> <span class="p">*(</span><span class="kt">uint</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0xA8</span><span class="p">)</span>
    <span class="p">:</span> <span class="p">*(</span><span class="kt">uint</span><span class="p">*)</span> <span class="p">(</span><span class="n">ptr</span> <span class="p">+</span> <span class="m">0xB8</span><span class="p">);</span>
</pre></table></code></div></div><p>One again we begin by obtaining a pointer to the base of our module (<code class="language-plaintext highlighter-rouge">basePtr</code>), aka the beginning of the PE header. We then get the value of <code class="language-plaintext highlighter-rouge">e_lfanew</code> as described previously and assign its value plus <code class="language-plaintext highlighter-rouge">basePtr</code> to <code class="language-plaintext highlighter-rouge">ptr</code>. Next thing we aquire is the value of <code class="language-plaintext highlighter-rouge">Magic</code>, the first field of the optional header and assign it to <code class="language-plaintext highlighter-rouge">optMagic</code>. Depending on bitness the value of <code class="language-plaintext highlighter-rouge">Magic</code> is either <code class="language-plaintext highlighter-rouge">0x10b</code> for 32bit or <code class="language-plaintext highlighter-rouge">0x20b</code> for 64bit. Since the next value that we need is located in the optional header we need to determine which header is present (32bit header is smaller than 64bit header, which results in different offsets). Next we check if <code class="language-plaintext highlighter-rouge">optMagic</code> is not <code class="language-plaintext highlighter-rouge">0x20b</code>, if that is the case we assign the value located at <code class="language-plaintext highlighter-rouge">ptr</code> plus offset <code class="language-plaintext highlighter-rouge">0xA8</code> to <code class="language-plaintext highlighter-rouge">DebugVirtualAddress</code>. The pointer chain points to the location of <code class="language-plaintext highlighter-rouge">Debug Directory RVA</code> in the 32bit optional header. If <code class="language-plaintext highlighter-rouge">optMagic</code> is <code class="language-plaintext highlighter-rouge">0x20b</code> a different offset <code class="language-plaintext highlighter-rouge">0xB8</code> will be added to <code class="language-plaintext highlighter-rouge">ptr</code> which results in the value of <code class="language-plaintext highlighter-rouge">Debug Directory RVA</code> in the 64bit optional header getting assigned to <code class="language-plaintext highlighter-rouge">DebugVirtualAddress</code>.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">basePtr</span> <span class="p">+=</span> <span class="n">DebugVirtualAddress</span><span class="p">;</span>
<span class="kt">uint</span> <span class="n">SizeOfData</span> <span class="p">=</span> <span class="p">*(</span><span class="kt">uint</span><span class="p">*)</span> <span class="p">(</span><span class="n">basePtr</span> <span class="p">+</span> <span class="m">0x10</span><span class="p">);</span>
<span class="kt">uint</span> <span class="n">AddressOfRawData</span> <span class="p">=</span> <span class="p">*(</span><span class="kt">uint</span><span class="p">*)</span> <span class="p">(</span><span class="n">basePtr</span> <span class="p">+</span> <span class="m">0x14</span><span class="p">);</span>
<span class="n">basePtr</span> <span class="p">-=</span> <span class="n">DebugVirtualAddress</span><span class="p">;</span>
</pre></table></code></div></div><p>After finding the relative virtual address (RVA) of the debug directory (stored in <code class="language-plaintext highlighter-rouge">DebugVirtualAddress</code>) we add it to <code class="language-plaintext highlighter-rouge">basePtr</code>. After we parse the first entry of the debug directory which is our payload, since in the stub generation we cleared the debug directory and added only our entry containing the payload. We only need 2 fields from the entry <code class="language-plaintext highlighter-rouge">SizeOfData</code> and <code class="language-plaintext highlighter-rouge">AddressOfRawData</code> to obtain them we apply an offset of <code class="language-plaintext highlighter-rouge">0x10</code> to <code class="language-plaintext highlighter-rouge">basePtr</code> since we added <code class="language-plaintext highlighter-rouge">DebugVirtualAddress</code> to <code class="language-plaintext highlighter-rouge">basePtr</code> it now points to the beginning of the debug directory. And the value at offset <code class="language-plaintext highlighter-rouge">0x10</code> in the debug directory entry is <code class="language-plaintext highlighter-rouge">SizeOfData</code>. Next we do the same for <code class="language-plaintext highlighter-rouge">AddressOfRawData</code> using the offset <code class="language-plaintext highlighter-rouge">0x14</code>. Once we have aquired these two values we subtract <code class="language-plaintext highlighter-rouge">DebugVirtualAddress</code> from <code class="language-plaintext highlighter-rouge">basePtr</code> to ensure its pointing to the beginning of the PE header again. That step is required since <code class="language-plaintext highlighter-rouge">AddressOfRawData</code> which is the location of our payload data, is relative to the base of the module.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">SizeOfData</span><span class="p">];</span>
<span class="n">basePtr</span> <span class="p">+=</span> <span class="n">AddressOfRawData</span><span class="p">;</span>
<span class="k">fixed</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*</span> <span class="n">rawData</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="p">*(</span><span class="n">rawData</span> <span class="p">+</span> <span class="n">i</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(*(</span><span class="n">basePtr</span> <span class="p">+</span> <span class="n">i</span><span class="p">)</span> <span class="p">^</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span> <span class="p">%</span> <span class="n">name</span><span class="p">.</span><span class="n">Length</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This snippet is almost identical to the PE section loader except the location we copy the data from is aquired by adding <code class="language-plaintext highlighter-rouge">AddressOfRawData</code> to <code class="language-plaintext highlighter-rouge">basePtr</code> and we use <code class="language-plaintext highlighter-rouge">SizeOfData</code> to initialize our buffer byte array. The copying, decryption, decompression and invoking is done exactly the same way as in the PE section loader.</p><h2 id="finnishing-the-packed-file"><span class="mr-2">Finnishing the packed file</span><a href="#finnishing-the-packed-file" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>After all the above is done all thats left to do is writing our stub module to disk. Once the file is written to disk youve got your own packed version of the input file.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dotnet/'>dotnet</a>, <a href='/categories/coding/'>coding</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Writing+a+Packer+-+dr4k0nia&url=https%3A%2F%2Fdr4k0nia.github.io%2Fposts%2FWriting-a-Packer%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/NixImports-a-NET-loader-using-HInvoke/">NixImports a .NET loader using HInvoke</a><li><a href="/posts/Analysing-a-sample-of-ArechClient2/">Analysing A Sample Of Arechclient2</a><li><a href="/posts/String-Obfuscation-The-Malware-Way/">String Obfuscation The Malware Way</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/HInvoke-and-avoiding-PInvoke/"><div class="card-body"> <em class="small" data-ts="1660159644" data-df="ll" > Aug 10, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HInvoke and avoiding PInvoke</h3><div class="text-muted small"><p> A very minimalistic approach of calling .net runtime functions or accessing properties using only hashes as identifiers. It does not leave any strings or import references since we dynamically reso...</p></div></div></a></div><div class="card"> <a href="/posts/Encrypting-Strings-In-NET/"><div class="card-body"> <em class="small" data-ts="1665862044" data-df="ll" > Oct 15, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Encrypting strings in .NET</h3><div class="text-muted small"><p> Implementing custom string encryption for .NET binaries utilizing an XOR-based cipher and AsmResolver. Encrypting strings is a common practice to slow down static analysis or evade automatic analys...</p></div></div></a></div><div class="card"> <a href="/posts/String-Obfuscation-The-Malware-Way/"><div class="card-body"> <em class="small" data-ts="1671132444" data-df="ll" > Dec 15, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>String Obfuscation The Malware Way</h3><div class="text-muted small"><p> Malware authors like to use string obfuscation to make their code harder to analyze and detect. One obfuscation technique is to insert special characters into a string, and then use some code to re...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Writing-a-simple-unpacker/" class="btn btn-outline-nord" prompt="Older"><p>Writing a simple Unpacker</p></a> <a href="/posts/Taking-a-look-at-AntiDumps/" class="btn btn-outline-nord" prompt="Newer"><p>Taking a look at AntiDumps</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/dr4k0nia">dr4k0nia</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
